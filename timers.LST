C51 COMPILER V9.51   TIMERS                                                                06/01/2016 09:49:50 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TIMERS
OBJECT MODULE PLACED IN timers.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe timers.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include "c8051F040.h"
   2          #include "stdlib.h"
   3          #include "string.h"
   4          #include "stdio.h"
   5          #include "main.h"
   6          
   7          //U16 OneSecConst;
   8          U32 msticks;
   9          extern bit RxCAN1;
  10          extern U8 xdata RelayChange;
  11          extern U16 xdata RelayCnf[4];
  12          extern MSGTABLE xdata *Mesgs;
  13          extern U8 xdata MesgCnt;
  14          extern CANFRAME xdata txframe;
  15          extern CANFRAME xdata OneTime[3];
  16          
  17          void Oscillator_Init(void)
  18          {
  19   1              char    SFPRPAGE_SAVE = SFRPAGE;        // Save Current SFR Page
  20   1      
  21   1              ////////////////////////////////////////
  22   1              // switch to external oscillator
  23   1              ////////////////////////////////////////
  24   1              SFRPAGE = CONFIG_PAGE;  // switch to config page to config oscillator
  25   1              
  26   1              OSCXCN  = 0x67;     // start external oscillator; 18.0/24.0 MHz Crystal
  27   1              codedelay(255);         // delay about 1ms  
  28   1      
  29   1              while ((OSCXCN & 0x80) == 0);   
  30   1      
  31   1              CLKSEL |= 0x01;         // switch to external oscillator
  32   1      
  33   1              SFRPAGE = SFPRPAGE_SAVE;        // Restore SFR page
  34   1      }
  35          
  36          // MilliSec Delay -  delay function
  37          void mSecDelay(unsigned int delay)
  38          {
  39   1              delay = delay + (int)msticks;
  40   1      
  41   1                                                                                                              // did delay wrap low? then
  42   1              while (delay < (int)msticks && !RxCAN1)                 // wait till msticks wraps once
  43   1              ;                                                                                               // delay should be > msticks to start
  44   1      
  45   1              while ((int)msticks < delay && !RxCAN1)                 // wait for msticks >= delay
  46   1              ;
  47   1      }
  48          
  49          void codedelay(unsigned int delay)
  50          {
  51   1              while (delay && !RxCAN1)
  52   1              {
  53   2                      delay--;
  54   2              }
  55   1      } 
C51 COMPILER V9.51   TIMERS                                                                06/01/2016 09:49:50 PAGE 2   

  56          
  57          
  58          // Start Timer3
  59          void Start_Timer3(U16 OneSecConst)
  60          {
  61   1              unsigned int Reload;
  62   1      
  63   1              // Configure Timer3 to auto-reload and generate an interrupt at interval
  64   1              // specified by <counts> using SYSCLK/12 as its time base.
  65   1              SFRPAGE = TMR3_PAGE;                            // Switch to Timer 3 page
  66   1      
  67   1              Reload = SYSCLK / OneSecConst;
  68   1      //      Reload = SYSCLK * .000256;
  69   1              TMR3CN = 0x00;                                  // Stop Timer3; Clear TF3;
  70   1              TMR3CF = 0x8;                           // use SYSCLK as timebase GLB
  71   1      
  72   1              RCAP3   = -Reload;                                      // Init reload values
  73   1              TMR3    = 0xffff;                               // set to reload immediately
  74   1      
  75   1              // debug - Timer3 high priority
  76   1              //EIP2 |= 0x01;
  77   1      
  78   1              EIE2 |= 0x01;                                   // enable Timer3 interrupts
  79   1              TR3 = 1;                                        // start Timer3
  80   1                                                                                              // Init Timer3 to generate interrupts - 256uSec,
  81   1                                                                                              // (4608 ticks @18M) or (6144 @24M)
  82   1                                                                                              // use SYSCLK instead of SYSCLK/12 for accuracy
  83   1                                                                                              // This leads to msticks being bytes 4-1 of 5 byte timer
  84   1                                                                                              // byte 0 is TMR3 / 18 (GLB)
  85   1              msticks = 0;
  86   1      }
  87          
  88          extern U32 keys,keyChange;
  89          void INT_T3_OV() interrupt 14                                   // Timer 3 overflow
  90          {
  91   1              TF3 = 0;                                                // clear TF3
  92   1              msticks++;
  93   1      
  94   1              ReadInputs();                                                           // read input selects and buttons.
  95   1      
  96   1              CheckMesgs();
  97   1      }
  98          
  99          
 100          U8 Rotary2value(U8 inbits,U8 old)
 101          {
 102   1              switch (inbits)
 103   1                      {
 104   2                      case 1:
 105   2                              inbits = 5;
 106   2                              break;
 107   2                      case 2:
 108   2                              inbits = 6;
 109   2                              break;
 110   2                      case 4:
 111   2                              inbits = 7;
 112   2                              break;
 113   2                      case 8:
 114   2                              inbits = 8;
 115   2                              break;
 116   2                      case 0x10:
 117   2                              inbits = 1;
C51 COMPILER V9.51   TIMERS                                                                06/01/2016 09:49:50 PAGE 3   

 118   2                              break;
 119   2                      case 0x20:
 120   2                              inbits = 2;
 121   2                              break;
 122   2                      case 0x40:
 123   2                              inbits = 3;
 124   2                              break;
 125   2                      case 0x80:
 126   2                              inbits = 4;
 127   2                              break;
 128   2                      default:
 129   2                              inbits =old;
 130   2                      }
 131   1              return (inbits);
 132   1      }
 133          
 134          void ReadInputs()
 135          {
 136   1              U32 Col1,Col2;
 137   1              U16 col;
 138   1              U8 Ign,Soft;
 139   1              U8 port1,port2,port3,temp;
 140   1      
 141   1              // Read Row 1 of buttons and Read Ignition Rotary
 142   1              ROW1 = 0;
 143   1              ROTARY_IGN = 0;
 144   1              codedelay(50);
 145   1      
 146   1              port1 = P1;
 147   1              port2 = P2; 
 148   1              port3 = P3;
 149   1              ROW1 = 1;
 150   1              ROTARY_IGN = 1;
 151   1      
 152   1              col = (U16)port1 + ((U16)(port2&0x3)<<8);
 153   1              Col1 = (U32)(((~col) & 0x3FF))<<18;
 154   1      
 155   1              temp = (port2 & 0xF0) + (port3 & 0xF);
 156   1              Ign = Rotary2value(~temp,((keys>>4)&0xF));
 157   1      
 158   1              // Read Row 2 of buttons and Read Soft Rotary
 159   1              ROW2 = 0;
 160   1              ROTARY_SOFT = 0;
 161   1              codedelay(50);
 162   1              
 163   1              port1 = P1;
 164   1              port2 = P2; 
 165   1              port3 = P3;
 166   1              ROW2 = 1;
 167   1              ROTARY_SOFT = 1;
 168   1      
 169   1              col = port1 + ((port2&0x3)<<8);
 170   1              Col2 = (U32)(((~col) & 0x3FF))<<8;
 171   1      
 172   1              temp = (port2 & 0xF0) + (port3 & 0xF);
 173   1              Soft = Rotary2value(~temp,(keys&0xF));
 174   1      
 175   1              keyChange |= keys ^ (Col1+Col2+((U32)Ign<<4)+(U32)Soft);        // set new changes
 176   1              keys = Col1+Col2+((U32)Ign<<4)+(U32)Soft;
 177   1      }
 178          
 179          
C51 COMPILER V9.51   TIMERS                                                                06/01/2016 09:49:50 PAGE 4   

 180          void CheckMesgs()
 181          {
 182   1              U8 i,j,port;
 183   1              bit found = 0;
 184   1      
 185   1              for (i = 0 ; i < TXBUFFS ; i++)
 186   1              {
 187   2                      if (OneTime[i].arbID)
 188   2                      {
 189   3                              if (OneTime[i].arbID & PORTFLG)
 190   3                                      port = 1;
 191   3                              else port = 0;
 192   3                              txframe.arbID = (OneTime[i].arbID & 0x9FFFFFFF);
 193   3                              txframe.sz = OneTime[i].sz;
 194   3                              for (j = 0 ; j < txframe.sz ; j++)
 195   3                                      txframe.cdat[j] = OneTime[i].cdat[j];
 196   3      
 197   3                              TxFrame(port);
 198   3                              OneTime[i].arbID = 0;
 199   3                              found = 1;
 200   3                      }
 201   2              }
 202   1      
 203   1              for (i = 0 ; i < MesgCnt ; i++)
 204   1              {
 205   2                      if ((Mesgs+i)->Rate <= (Mesgs+i)->ticks && !found)      // output
 206   2                      {
 207   3                              (Mesgs+i)->ticks=0;
 208   3      
 209   3                              if ((Mesgs+i)->ID & PORTFLG) port = 1; else port = 0;
 210   3                              txframe.arbID = (Mesgs+i)->ID & 0x9FFFFFFF;                                                                                             
 211   3                              txframe.sz = (Mesgs+i)->cnt;
 212   3                              for (j = 0 ; j < txframe.sz ; j++)
 213   3                                      txframe.cdat[j] = (Mesgs+i)->dat[j];
 214   3      
 215   3                              TxFrame(port);
 216   3                              found = 1;
 217   3      
 218   3                              if ((Mesgs+i)->Altered)
 219   3                              {
 220   4                                      if ((Mesgs+i)->Altered != 0xFF) // not held data
 221   4                                      {
 222   5                                              (Mesgs+i)->Altered--;
 223   5                                              if (!(Mesgs+i)->Altered)        // time to restore data
 224   5                                              {
 225   6                                                      for (j = 0 ; j < (Mesgs+i)->cnt ; j++)
 226   6                                                              (Mesgs+i)->dat[j] = (Mesgs+i)->Restore[j];
 227   6                                              }
 228   5                                      }
 229   4                              }
 230   3      
 231   3                              for (j = 0 ; j < 4 ; j++)
 232   3                              {
 233   4                                      if ((RelayCnf[j]&0xF00) == REL_TX) // Relay configured to TxMesg
 234   4                                      {
 235   5                                              if ((RelayCnf[j]&0xFF) == i)            // outputing correct message
 236   5                                                      RelayChange |= 1<<j;                    // flag for relay change
 237   5                                      }
 238   4                              }
 239   3                      }
 240   2                      else
 241   2                              (Mesgs+i)->ticks++;
C51 COMPILER V9.51   TIMERS                                                                06/01/2016 09:49:50 PAGE 5   

 242   2              }
 243   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1482    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
