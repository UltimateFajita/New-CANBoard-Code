C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USER
OBJECT MODULE PLACED IN user.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe user.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          //Can Bus Simulator
   2          #include "c8051F040.h"
   3          #include "stdlib.h"
   4          #include "string.h"
   5          #include "stdio.h"
   6          #include "main.h"
   7          #include "spi.h"
   8          
   9          extern CANFRAME xdata OneTime[TXBUFFS];
  10          extern CANFRAME xdata rxframe0[RX0BUFFERS];
  11          extern U8 xdata MaxMesgs,MaxRxTraps;
  12          
  13          extern MSGTABLE xdata *Mesgs;
  14          extern U8 xdata MesgCnt;
  15          extern BUTTABLE xdata *Buttons;
  16          extern U8 xdata ButtCnt;
  17          extern RxMESG xdata *RxMesg;
  18          extern U8 xdata RxCnt;
  19          extern U16 xdata RelayCnf[4];
  20          extern U8 xdata RelayChange;
  21          extern U8 xdata RxBuffCnt[2];
  22          
  23          extern U32 keys,keyChange;
  24          extern bit RxCAN0,RxCAN1;
  25          extern U32 msticks;
  26          
  27          void User1()    // program select 1 - CUSW
  28          {       
  29   1              U32 StartTicks = 0;
  30   1              U8  index,index1,ErrCnt,counter,vin,error, cnt;
  31   1              bit IGN_OFF=1;
  32   1      
  33   1              char VIN[17] = "1C3ADECZ7GV1002UC";
  34   1      
  35   1              error = 0;      ErrCnt=0;
  36   1      
  37   1      
  38   1      
  39   1      /***************************************************************************************
  40   1      ****************************************************************************************
  41   1              CAUTION WATCH XDATA BOUNDARIES.  NOT AUTOMATIC ITS UP TO YOU!!!!!!
  42   1      ****************************************************************************************
  43   1              // CODE CURRENTLY USES 809 xdata bytes.  THEREFORE STARTING CAN BE AT 0x32A
  44   1              // watch at compile the xdata bytes used. if xdata > 810d need to change below
  45   1              // xdata space ends at 0xFFF.
  46   1      ***************************************************************************************/
  47   1      //      Buttons = (BUTTABLE xdata *)0x32A;      // 20 buttons takes 32Abytes => 0x32A-0x4E1
  48   1              ButtCnt = 0;                                            // each Button = 20 bytes
  49   1      
  50   1      //      Mesgs = (MSGTABLE xdata *)0x4E2;        // 0x4E2-0x93F -> space for 43 Tx messages 
  51   1              MesgCnt = 0;                                            // each Mesgs = 26 bytes
  52   1      
  53   1      //      RxMesg = (RxMESG xdata *)0x940;         // 0x940-0xFF8 -> space for 43 Rx messages 
  54   1              RxCnt = 0;                                                      // each RxMesg = 40 bytes
  55   1      
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 2   

  56   1      // AUTOMATED above some,
  57   1      // Make Sure XDATASPACE define follows compile output value  
  58   1      #define XDATASPACE 810          // starting free address
  59   1      
  60   1      /***************************************************************************************
  61   1      // Currently (809 xdata start) you get 43 Tx messages and 43 Rx message traps.  If you 
  62   1      // need more of one and less of the other you can manipulate the starting numbers below
  63   1      // to get it to work.
  64   1      // also note RX0 buff size is 32 messages on CAN0, and RX1 buff size is 16 for CAN1
  65   1      ***************************************************************************************/
  66   1              MaxMesgs = 45;                  // number of Tx message configs
  67   1              MaxRxTraps = 45;                // number of Rx message configs
  68   1              while(!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))    // 20 button configs  
  69   1              {
  70   2                      MaxRxTraps--;           // reduce Message buffers till it fits.
  71   2                      if (!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))
  72   2                              MaxMesgs--;             // reduce Message buffers till it fits
  73   2              }
  74   1      /**************************************************************************************/
  75   1      
  76   1      
  77   1      /*************************************************************************
  78   1              Repeating message setups
  79   1              example below-
  80   1              message ID 0x6E2 is created at rate of 500mSec on port 1 (C). With 8 bytes 
  81   1              of data, shown are it's defaults.
  82   1      **************************************************************************/
  83   1              // build repetative message 6E2 on CAN1
  84   1              OneTime[0].cdat[0] = 0;
  85   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
  86   1              OneTime[0].cdat[2] = 0;
  87   1              OneTime[0].cdat[3] = 0;
  88   1              OneTime[0].cdat[4] = 0;
  89   1              OneTime[0].cdat[5] = 0;
  90   1              OneTime[0].cdat[6] = 0;
  91   1              OneTime[0].cdat[7] = 0;
  92   1      //U8 AddMessage(U8 port,U32 ID,U16 Rate,U8 cnt,U8 dat[8])
  93   1              AddMessage(0,0x339,500,8,OneTime[0].cdat);
  94   1      
  95   1              // build repetative message 3E0 on CAN0 
  96   1              vin = 0;
  97   1              OneTime[0].cdat[0] = 0;
  98   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
  99   1              OneTime[0].cdat[2] = 0;
 100   1              OneTime[0].cdat[3] = 0;
 101   1              OneTime[0].cdat[4] = 0;
 102   1              OneTime[0].cdat[5] = 0;
 103   1              OneTime[0].cdat[6] = 0;
 104   1              OneTime[0].cdat[7] = 0;
 105   1              AddMessage(0,0x33B,50,8,OneTime[0].cdat);
 106   1      
 107   1              // build repetative message 46C on CAN0 
 108   1              OneTime[0].cdat[0] = 0;
 109   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 110   1              OneTime[0].cdat[2] = 0;
 111   1              OneTime[0].cdat[3] = 0;
 112   1              OneTime[0].cdat[4] = 0;
 113   1              OneTime[0].cdat[5] = 0;
 114   1              OneTime[0].cdat[6] = 0;
 115   1              OneTime[0].cdat[7] = 0;
 116   1              AddMessage(0,0x3CB,500,8,OneTime[0].cdat);
 117   1              
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 3   

 118   1              OneTime[0].cdat[0] = 0;
 119   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 120   1              OneTime[0].cdat[2] = 0;
 121   1              OneTime[0].cdat[3] = 0;
 122   1              AddMessage(0,0x3D1,500,4,OneTime[0].cdat);
 123   1              
 124   1              OneTime[0].cdat[0] = 0;
 125   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 126   1              OneTime[0].cdat[2] = 0;
 127   1              OneTime[0].cdat[3] = 0;
 128   1              OneTime[0].cdat[4] = 0;
 129   1              OneTime[0].cdat[5] = 0;
 130   1              OneTime[0].cdat[6] = 0;
 131   1              OneTime[0].cdat[7] = 0;
 132   1              AddMessage(0,0x3D3,500,8,OneTime[0].cdat);
 133   1              
 134   1              OneTime[0].cdat[0] = 0;
 135   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 136   1              OneTime[0].cdat[2] = 0;
 137   1              OneTime[0].cdat[3] = 0x05;
 138   1              OneTime[0].cdat[4] = 0;
 139   1              AddMessage(0,0x499,500,5,OneTime[0].cdat);
 140   1              
 141   1              OneTime[0].cdat[0] = 0;
 142   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 143   1              OneTime[0].cdat[2] = 0;
 144   1              OneTime[0].cdat[3] = 0;
 145   1              OneTime[0].cdat[4] = 0;
 146   1              OneTime[0].cdat[5] = 0;
 147   1              OneTime[0].cdat[6] = 0;
 148   1              OneTime[0].cdat[7] = 0;
 149   1              AddMessage(0,0x4A3,500,8,OneTime[0].cdat);
 150   1              
 151   1              OneTime[0].cdat[0] = 0;
 152   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 153   1              OneTime[0].cdat[2] = 0;
 154   1              OneTime[0].cdat[3] = 0;
 155   1              AddMessage(0,0x548,500,4,OneTime[0].cdat);
 156   1              
 157   1              OneTime[0].cdat[0] = 0;
 158   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 159   1              AddMessage(0,0x5C8,500,2,OneTime[0].cdat);
 160   1              
 161   1              OneTime[0].cdat[0] = 0xC8;
 162   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 163   1              OneTime[0].cdat[2] = 0xFF;
 164   1              OneTime[0].cdat[3] = 0xFF;
 165   1              OneTime[0].cdat[4] = 0xFF;
 166   1              OneTime[0].cdat[5] = 0xFF;
 167   1              OneTime[0].cdat[6] = 0;
 168   1              OneTime[0].cdat[7] = 0;
 169   1              AddMessage(0,0x5CA,500,8,OneTime[0].cdat);
 170   1              
 171   1              OneTime[0].cdat[0] = 0;
 172   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 173   1              OneTime[0].cdat[2] = 0;
 174   1              OneTime[0].cdat[3] = 0;
 175   1              AddMessage(0,0x5CC,500,4,OneTime[0].cdat);
 176   1              
 177   1              OneTime[0].cdat[0] = 0;
 178   1              OneTime[0].cdat[1] = 0x20;      // using OneTime structure as temp storage
 179   1              OneTime[0].cdat[2] = 0;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 4   

 180   1              OneTime[0].cdat[3] = 0;
 181   1              OneTime[0].cdat[4] = 0;
 182   1              AddMessage(0,0x5DC,500,5,OneTime[0].cdat);
 183   1              
 184   1              OneTime[0].cdat[0] = 0;
 185   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 186   1              OneTime[0].cdat[2] = 0;
 187   1              OneTime[0].cdat[3] = 0;
 188   1              OneTime[0].cdat[4] = 0;
 189   1              OneTime[0].cdat[5] = 0;
 190   1              OneTime[0].cdat[6] = 0;
 191   1              OneTime[0].cdat[7] = 0;
 192   1              AddMessage(0,0x6A4,500,8,OneTime[0].cdat);
 193   1              
 194   1              OneTime[0].cdat[0] = 0;
 195   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 196   1              AddMessage(0,0x75A,500,2,OneTime[0].cdat);
 197   1              
 198   1              OneTime[0].cdat[0] = 0x0F;
 199   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 200   1              OneTime[0].cdat[2] = 0;
 201   1              AddMessage(0,0x762,500,3,OneTime[0].cdat);
 202   1              
 203   1              OneTime[0].cdat[0] = 0;
 204   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 205   1              OneTime[0].cdat[2] = 0;
 206   1              OneTime[0].cdat[3] = 0;
 207   1              AddMessage(0,0x772,500,4,OneTime[0].cdat);
 208   1      
 209   1                      // build repetative message 6EA on CAN0
 210   1              OneTime[0].cdat[0] = 0;
 211   1              OneTime[0].cdat[1] = 0x22;      // using OneTime structure as temp storage
 212   1              OneTime[0].cdat[0] = 0;
 213   1              OneTime[0].cdat[1] = 0;
 214   1              OneTime[0].cdat[1] = 0;
 215   1              AddMessage(0,0x190,1000,5,OneTime[0].cdat);
 216   1      
 217   1                      // build repetative message 6EA on CAN0
 218   1              OneTime[0].cdat[0] = 0;
 219   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 220   1              OneTime[0].cdat[2] = 0;
 221   1              OneTime[0].cdat[3] = 0;
 222   1              OneTime[0].cdat[4] = 0;
 223   1              OneTime[0].cdat[5] = 0;
 224   1              OneTime[0].cdat[6] = 0;
 225   1              OneTime[0].cdat[7] = 0;
 226   1              AddMessage(0,0x098,1000,8,OneTime[0].cdat);
 227   1              
 228   1              
 229   1              OneTime[0].cdat[0] = 0;
 230   1              OneTime[0].cdat[1] = 0x02;      // using OneTime structure as temp storage
 231   1              OneTime[0].cdat[2] = 0;
 232   1              OneTime[0].cdat[3] = 0;
 233   1              OneTime[0].cdat[4] = 0;
 234   1              OneTime[0].cdat[5] = 0;
 235   1              AddMessage(0,0xE094000,500,6,OneTime[0].cdat);
 236   1              
 237   1              OneTime[0].cdat[0] = 0;
 238   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 239   1              OneTime[0].cdat[2] = 0;
 240   1              OneTime[0].cdat[3] = 0;
 241   1              OneTime[0].cdat[4] = 0;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 5   

 242   1              OneTime[0].cdat[5] = 0;
 243   1              OneTime[0].cdat[6] = 0;
 244   1              OneTime[0].cdat[7] = 0;
 245   1              AddMessage(0,0x5E0,500,8,OneTime[0].cdat);
 246   1              
 247   1              OneTime[0].cdat[0] = 0;
 248   1              OneTime[0].cdat[1] = 0; // using OneTime structure as temp storage
 249   1              OneTime[0].cdat[2] = 0;
 250   1              OneTime[0].cdat[3] = 0;
 251   1              OneTime[0].cdat[4] = 0;
 252   1              OneTime[0].cdat[5] = 0;
 253   1              OneTime[0].cdat[6] = 0;
 254   1              OneTime[0].cdat[7] = 0;
 255   1              AddMessage(0,0x5E2,500,8,OneTime[0].cdat);
 256   1      
 257   1      /*************************************************************************
 258   1              Button setup
 259   1              example below -
 260   1              pressing button 1 causes byte 5 of message 0x6E2 to be altered to 0xAA 
 261   1              for the next 5 outputs. The mask clears byte 5 leaving the rest alone.  
 262   1              The value (0xAA) is ORed into byte 5.
 263   1      **************************************************************************/
 264   1              #define BUTTONMASK 0xF  // only button 1 defined (bit 1) 
 265   1      
 266   1              // Volume Up
 267   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 268   1              OneTime[0].cdat[1] = 0xFF;
 269   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 270   1              OneTime[0].cdat[3] = 0xFF;
 271   1              OneTime[0].cdat[4] = 0xFF;
 272   1              OneTime[0].cdat[5] = 0;         
 273   1              OneTime[0].cdat[6] = 0xFF;
 274   1              OneTime[0].cdat[7] = 0xFF;
 275   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 276   1              OneTime[1].cdat[1] = 0;
 277   1              OneTime[1].cdat[2] = 0;
 278   1              OneTime[1].cdat[3] = 0;
 279   1              OneTime[1].cdat[4] = 0;
 280   1              OneTime[1].cdat[5] = 0x08;
 281   1              OneTime[1].cdat[6] = 0;
 282   1              OneTime[1].cdat[7] = 0;
 283   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 284   1              SimpleButtonConfig(19,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 285   1      
 286   1              // Volume Down
 287   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 288   1              OneTime[0].cdat[1] = 0xFF;
 289   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 290   1              OneTime[0].cdat[3] = 0xFF;
 291   1              OneTime[0].cdat[4] = 0xFF;
 292   1              OneTime[0].cdat[5] = 0;         
 293   1              OneTime[0].cdat[6] = 0xFF;
 294   1              OneTime[0].cdat[7] = 0xFF;
 295   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 296   1              OneTime[1].cdat[1] = 0;
 297   1              OneTime[1].cdat[2] = 0;
 298   1              OneTime[1].cdat[3] = 0;
 299   1              OneTime[1].cdat[4] = 0;
 300   1              OneTime[1].cdat[5] = 0x20;
 301   1              OneTime[1].cdat[6] = 0;
 302   1              OneTime[1].cdat[7] = 0;
 303   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 6   

 304   1              SimpleButtonConfig(9,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 305   1      
 306   1              // Mode
 307   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 308   1              OneTime[0].cdat[1] = 0xFF;
 309   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 310   1              OneTime[0].cdat[3] = 0xFF;
 311   1              OneTime[0].cdat[4] = 0xFF;
 312   1              OneTime[0].cdat[5] = 0;         
 313   1              OneTime[0].cdat[6] = 0xFF;
 314   1              OneTime[0].cdat[7] = 0xFF;
 315   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 316   1              OneTime[1].cdat[1] = 0;
 317   1              OneTime[1].cdat[2] = 0;
 318   1              OneTime[1].cdat[3] = 0;
 319   1              OneTime[1].cdat[4] = 0;
 320   1              OneTime[1].cdat[5] = 0x80;
 321   1              OneTime[1].cdat[6] = 0;
 322   1              OneTime[1].cdat[7] = 0;
 323   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 324   1              SimpleButtonConfig(18,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 325   1      
 326   1              // Preset
 327   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 328   1              OneTime[0].cdat[1] = 0xFF;
 329   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 330   1              OneTime[0].cdat[3] = 0;
 331   1              OneTime[0].cdat[4] = 0xFF;
 332   1              OneTime[0].cdat[5] = 0xFF;              
 333   1              OneTime[0].cdat[6] = 0xFF;
 334   1              OneTime[0].cdat[7] = 0xFF;
 335   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 336   1              OneTime[1].cdat[1] = 0;
 337   1              OneTime[1].cdat[2] = 0;
 338   1              OneTime[1].cdat[3] = 0x08;
 339   1              OneTime[1].cdat[4] = 0;
 340   1              OneTime[1].cdat[5] = 0;
 341   1              OneTime[1].cdat[6] = 0;
 342   1              OneTime[1].cdat[7] = 0;
 343   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 344   1              SimpleButtonConfig(8,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 345   1      
 346   1              // Seek Up
 347   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 348   1              OneTime[0].cdat[1] = 0xFF;
 349   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 350   1              OneTime[0].cdat[3] = 0xFF;
 351   1              OneTime[0].cdat[4] = 0;
 352   1              OneTime[0].cdat[5] = 0xFF;              
 353   1              OneTime[0].cdat[6] = 0xFF;
 354   1              OneTime[0].cdat[7] = 0xFF;
 355   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 356   1              OneTime[1].cdat[1] = 0;
 357   1              OneTime[1].cdat[2] = 0;
 358   1              OneTime[1].cdat[3] = 0;
 359   1              OneTime[1].cdat[4] = 0x02;
 360   1              OneTime[1].cdat[5] = 0;
 361   1              OneTime[1].cdat[6] = 0;
 362   1              OneTime[1].cdat[7] = 0;
 363   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 364   1              SimpleButtonConfig(17,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 365   1      
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 7   

 366   1              // Seek Down
 367   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 368   1              OneTime[0].cdat[1] = 0xFF;
 369   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 370   1              OneTime[0].cdat[3] = 0xFF;
 371   1              OneTime[0].cdat[4] = 0;
 372   1              OneTime[0].cdat[5] = 0xFF;              
 373   1              OneTime[0].cdat[6] = 0xFF;
 374   1              OneTime[0].cdat[7] = 0xFF;
 375   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 376   1              OneTime[1].cdat[1] = 0;
 377   1              OneTime[1].cdat[2] = 0;
 378   1              OneTime[1].cdat[3] = 0;
 379   1              OneTime[1].cdat[4] = 0x08;
 380   1              OneTime[1].cdat[5] = 0;
 381   1              OneTime[1].cdat[6] = 0;
 382   1              OneTime[1].cdat[7] = 0;
 383   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 384   1              SimpleButtonConfig(7,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 385   1      
 386   1              // Phone Pickup
 387   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 388   1              OneTime[0].cdat[1] = 0xFF;
 389   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 390   1              OneTime[0].cdat[3] = 0xFF;
 391   1              OneTime[0].cdat[4] = 0;
 392   1              OneTime[0].cdat[5] = 0xFF;              
 393   1              OneTime[0].cdat[6] = 0xFF;
 394   1              OneTime[0].cdat[7] = 0xFF;
 395   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 396   1              OneTime[1].cdat[1] = 0;
 397   1              OneTime[1].cdat[2] = 0;
 398   1              OneTime[1].cdat[3] = 0;
 399   1              OneTime[1].cdat[4] = 0x80;
 400   1              OneTime[1].cdat[5] = 0;
 401   1              OneTime[1].cdat[6] = 0;
 402   1              OneTime[1].cdat[7] = 0;
 403   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 404   1              SimpleButtonConfig(16,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 405   1      
 406   1              // Phone Hangup
 407   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 408   1              OneTime[0].cdat[1] = 0xFF;
 409   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 410   1              OneTime[0].cdat[3] = 0;
 411   1              OneTime[0].cdat[4] = 0xFF;
 412   1              OneTime[0].cdat[5] = 0xFF;              
 413   1              OneTime[0].cdat[6] = 0xFF;
 414   1              OneTime[0].cdat[7] = 0xFF;
 415   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 416   1              OneTime[1].cdat[1] = 0;
 417   1              OneTime[1].cdat[2] = 0;
 418   1              OneTime[1].cdat[3] = 0x02;
 419   1              OneTime[1].cdat[4] = 0;
 420   1              OneTime[1].cdat[5] = 0;
 421   1              OneTime[1].cdat[6] = 0;
 422   1              OneTime[1].cdat[7] = 0;
 423   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 424   1              SimpleButtonConfig(6,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 425   1      
 426   1              // VR
 427   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 8   

 428   1              OneTime[0].cdat[1] = 0xFF;
 429   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 430   1              OneTime[0].cdat[3] = 0;
 431   1              OneTime[0].cdat[4] = 0xFF;
 432   1              OneTime[0].cdat[5] = 0xFF;              
 433   1              OneTime[0].cdat[6] = 0xFF;
 434   1              OneTime[0].cdat[7] = 0xFF;
 435   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 436   1              OneTime[1].cdat[1] = 0;
 437   1              OneTime[1].cdat[2] = 0;
 438   1              OneTime[1].cdat[3] = 0x20;
 439   1              OneTime[1].cdat[4] = 0;
 440   1              OneTime[1].cdat[5] = 0;
 441   1              OneTime[1].cdat[6] = 0;
 442   1              OneTime[1].cdat[7] = 0;
 443   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 444   1              SimpleButtonConfig(15,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 445   1      
 446   1              // Screen Off
 447   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 448   1              OneTime[0].cdat[1] = 0;
 449   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 450   1              OneTime[0].cdat[3] = 0xFF;
 451   1              OneTime[0].cdat[4] = 0xFF;
 452   1              OneTime[0].cdat[5] = 0xFF;              
 453   1              OneTime[0].cdat[6] = 0xFF;
 454   1              OneTime[0].cdat[7] = 0xFF;
 455   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 456   1              OneTime[1].cdat[1] = 0x10;
 457   1              OneTime[1].cdat[2] = 0;
 458   1              OneTime[1].cdat[3] = 0;
 459   1              OneTime[1].cdat[4] = 0;
 460   1              OneTime[1].cdat[5] = 0;
 461   1              OneTime[1].cdat[6] = 0;
 462   1              OneTime[1].cdat[7] = 0;
 463   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 464   1              SimpleButtonConfig(5,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
 465   1      
 466   1              // Mute
 467   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
 468   1              OneTime[0].cdat[1] = 0xFF;
 469   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 470   1              OneTime[0].cdat[3] = 0xFF;
 471   1              OneTime[0].cdat[4] = 0xFF;
 472   1              OneTime[0].cdat[5] = 0xFF;              
 473   1              OneTime[0].cdat[6] = 0xFF;
 474   1              OneTime[0].cdat[7] = 0xFF;
 475   1              OneTime[1].cdat[0] = 0x02;              // values (ORed)
 476   1              OneTime[1].cdat[1] = 0;
 477   1              OneTime[1].cdat[2] = 0;
 478   1              OneTime[1].cdat[3] = 0;
 479   1              OneTime[1].cdat[4] = 0;
 480   1              OneTime[1].cdat[5] = 0;
 481   1              OneTime[1].cdat[6] = 0;
 482   1              OneTime[1].cdat[7] = 0;
 483   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 484   1              SimpleButtonConfig(14,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
 485   1      
 486   1              // Back
 487   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 488   1              OneTime[0].cdat[1] = 0;
 489   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 9   

 490   1              OneTime[0].cdat[3] = 0xFF;
 491   1              OneTime[0].cdat[4] = 0xFF;
 492   1              OneTime[0].cdat[5] = 0xFF;              
 493   1              OneTime[0].cdat[6] = 0xFF;
 494   1              OneTime[0].cdat[7] = 0xFF;
 495   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 496   1              OneTime[1].cdat[1] = 0x01;
 497   1              OneTime[1].cdat[2] = 0;
 498   1              OneTime[1].cdat[3] = 0;
 499   1              OneTime[1].cdat[4] = 0;
 500   1              OneTime[1].cdat[5] = 0;
 501   1              OneTime[1].cdat[6] = 0;
 502   1              OneTime[1].cdat[7] = 0;
 503   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 504   1              SimpleButtonConfig(4,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
 505   1      
 506   1              // Browse/Enter
 507   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
 508   1              OneTime[0].cdat[1] = 0xFF;
 509   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 510   1              OneTime[0].cdat[3] = 0xFF;
 511   1              OneTime[0].cdat[4] = 0xFF;
 512   1              OneTime[0].cdat[5] = 0xFF;              
 513   1              OneTime[0].cdat[6] = 0xFF;
 514   1              OneTime[0].cdat[7] = 0xFF;
 515   1              OneTime[1].cdat[0] = 0x01;              // values (ORed)
 516   1              OneTime[1].cdat[1] = 0;
 517   1              OneTime[1].cdat[2] = 0;
 518   1              OneTime[1].cdat[3] = 0;
 519   1              OneTime[1].cdat[4] = 0;
 520   1              OneTime[1].cdat[5] = 0;
 521   1              OneTime[1].cdat[6] = 0;
 522   1              OneTime[1].cdat[7] = 0;
 523   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 524   1              SimpleButtonConfig(13,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
 525   1      
 526   1              // Screenshot
 527   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 528   1              OneTime[0].cdat[1] = 0xFF;
 529   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 530   1              OneTime[0].cdat[3] = 0xFF;
 531   1              OneTime[0].cdat[4] = 0;
 532   1              OneTime[0].cdat[5] = 0xFF;              
 533   1              OneTime[0].cdat[6] = 0xFF;
 534   1              OneTime[0].cdat[7] = 0xFF;
 535   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 536   1              OneTime[1].cdat[1] = 0;
 537   1              OneTime[1].cdat[2] = 0;
 538   1              OneTime[1].cdat[3] = 0;
 539   1              OneTime[1].cdat[4] = 0xC8;
 540   1              OneTime[1].cdat[5] = 0;
 541   1              OneTime[1].cdat[6] = 0;
 542   1              OneTime[1].cdat[7] = 0;
 543   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 544   1              SimpleButtonConfig(3,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,12);
 545   1      
 546   1      
 547   1              // ENG. Mode
 548   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 549   1              OneTime[0].cdat[1] = 0xFF;
 550   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 551   1              OneTime[0].cdat[3] = 0xFF;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 10  

 552   1              OneTime[0].cdat[4] = 0;
 553   1              OneTime[0].cdat[5] = 0xFF;              
 554   1              OneTime[0].cdat[6] = 0xFF;
 555   1              OneTime[0].cdat[7] = 0xFF;
 556   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 557   1              OneTime[1].cdat[1] = 0;
 558   1              OneTime[1].cdat[2] = 0;
 559   1              OneTime[1].cdat[3] = 0;
 560   1              OneTime[1].cdat[4] = 0xC0;
 561   1              OneTime[1].cdat[5] = 0;
 562   1              OneTime[1].cdat[6] = 0;
 563   1              OneTime[1].cdat[7] = 0;
 564   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 565   1              SimpleButtonConfig(12,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,12);
 566   1      
 567   1              // Dealer Mode
 568   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 569   1              OneTime[0].cdat[1] = 0xFF;
 570   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 571   1              OneTime[0].cdat[3] = 0xFF;
 572   1              OneTime[0].cdat[4] = 0;
 573   1              OneTime[0].cdat[5] = 0xFF;              
 574   1              OneTime[0].cdat[6] = 0xFF;
 575   1              OneTime[0].cdat[7] = 0xFF;
 576   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 577   1              OneTime[1].cdat[1] = 0;
 578   1              OneTime[1].cdat[2] = 0;
 579   1              OneTime[1].cdat[3] = 0;
 580   1              OneTime[1].cdat[4] = 0xC4;
 581   1              OneTime[1].cdat[5] = 0;
 582   1              OneTime[1].cdat[6] = 0;
 583   1              OneTime[1].cdat[7] = 0;
 584   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 585   1              SimpleButtonConfig(2,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,12);
 586   1      
 587   1      /*
 588   1              // 911
 589   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 590   1              OneTime[0].cdat[1] = 0xFF;
 591   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 592   1              OneTime[0].cdat[3] = 0xFF;
 593   1              OneTime[0].cdat[4] = 0;
 594   1              OneTime[0].cdat[5] = 0xFF;              
 595   1              OneTime[0].cdat[6] = 0xFF;
 596   1              OneTime[0].cdat[7] = 0xFF;
 597   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 598   1              OneTime[1].cdat[1] = 0;
 599   1              OneTime[1].cdat[2] = 0;
 600   1              OneTime[1].cdat[3] = 0;
 601   1              OneTime[1].cdat[4] = 0x80;
 602   1              OneTime[1].cdat[5] = 0;
 603   1              OneTime[1].cdat[6] = 0;
 604   1              OneTime[1].cdat[7] = 0;
 605   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 606   1              SimpleButtonConfig(11,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 607   1      
 608   1              // Assist
 609   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 610   1              OneTime[0].cdat[1] = 0xFF;
 611   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 612   1              OneTime[0].cdat[3] = 0xFF;
 613   1              OneTime[0].cdat[4] = 0;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 11  

 614   1              OneTime[0].cdat[5] = 0xFF;              
 615   1              OneTime[0].cdat[6] = 0xFF;
 616   1              OneTime[0].cdat[7] = 0xFF;
 617   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 618   1              OneTime[1].cdat[1] = 0;
 619   1              OneTime[1].cdat[2] = 0;
 620   1              OneTime[1].cdat[3] = 0;
 621   1              OneTime[1].cdat[4] = 0x80;
 622   1              OneTime[1].cdat[5] = 0;
 623   1              OneTime[1].cdat[6] = 0;
 624   1              OneTime[1].cdat[7] = 0;
 625   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 626   1              SimpleButtonConfig(1,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 627   1      
 628   1              // Door Ajar
 629   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 630   1              OneTime[0].cdat[1] = 0xFF;
 631   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 632   1              OneTime[0].cdat[3] = 0xFF;
 633   1              OneTime[0].cdat[4] = 0;
 634   1              OneTime[0].cdat[5] = 0xFF;              
 635   1              OneTime[0].cdat[6] = 0xFF;
 636   1              OneTime[0].cdat[7] = 0xFF;
 637   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 638   1              OneTime[1].cdat[1] = 0;
 639   1              OneTime[1].cdat[2] = 0;
 640   1              OneTime[1].cdat[3] = 0;
 641   1              OneTime[1].cdat[4] = 0x80;
 642   1              OneTime[1].cdat[5] = 0;
 643   1              OneTime[1].cdat[6] = 0;
 644   1              OneTime[1].cdat[7] = 0;
 645   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 646   1              SimpleButtonConfig(10,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 647   1      
 648   1              // Theft Alarm
 649   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 650   1              OneTime[0].cdat[1] = 0xFF;
 651   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 652   1              OneTime[0].cdat[3] = 0xFF;
 653   1              OneTime[0].cdat[4] = 0;
 654   1              OneTime[0].cdat[5] = 0xFF;              
 655   1              OneTime[0].cdat[6] = 0xFF;
 656   1              OneTime[0].cdat[7] = 0xFF;
 657   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 658   1              OneTime[1].cdat[1] = 0;
 659   1              OneTime[1].cdat[2] = 0;
 660   1              OneTime[1].cdat[3] = 0;
 661   1              OneTime[1].cdat[4] = 0x80;
 662   1              OneTime[1].cdat[5] = 0;
 663   1              OneTime[1].cdat[6] = 0;
 664   1              OneTime[1].cdat[7] = 0;
 665   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
 666   1              SimpleButtonConfig(,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
 667   1      */
 668   1      
 669   1      
 670   1      
 671   1      /*************************************************************************
 672   1              RxMessage filters / traps
 673   1              Below example:
 674   1              First half, Watches for ID 0x6E8 on can port 1 (C).  Only byte 3 matters 
 675   1              as the mask is set to 0's for all else.  The matching value required in  
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 12  

 676   1              byte 3 is 0x58. 8 bytes expected.
 677   1              Second half, configures output message 0x6E3 on port 1 (C). 8 bytes in 
 678   1              count.  mask is ANDed with cyclic message and ORed with value, but in 
 679   1              this example there is no cyclic message, therefor mask is ignored and 
 680   1              value is just output as the data 1 time. Take care to use the index value
 681   1              returned from the first function as input parameter to 2nd function
 682   1      **************************************************************************/
 683   1              OneTime[0].cdat[0] = 0;         // mask bits (0's don't cares, 1's are matches)
 684   1              OneTime[0].cdat[1] = 0;
 685   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
 686   1              OneTime[0].cdat[3] = 0xFF;      // this byte matters
 687   1              OneTime[0].cdat[4] = 0;
 688   1              OneTime[0].cdat[5] = 0;  
 689   1              OneTime[0].cdat[6] = 0;
 690   1              OneTime[0].cdat[7] = 0;
 691   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 692   1              OneTime[1].cdat[1] = 0;
 693   1              OneTime[1].cdat[2] = 0;
 694   1              OneTime[1].cdat[3] = 0x58;      // selector switches to x58 causes triggers
 695   1              OneTime[1].cdat[4] = 0;
 696   1              OneTime[1].cdat[5] = 0;
 697   1              OneTime[1].cdat[6] = 0;
 698   1              OneTime[1].cdat[7] = 0;
 699   1      // configure Rx filter, look for this message match
 700   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
 701   1              index = RxMessageConfig1(1,0x6E8,OneTime[0].cdat,OneTime[1].cdat,8);
 702   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 703   1              OneTime[0].cdat[1] = 0xFF;
 704   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
 705   1              OneTime[0].cdat[3] = 0xFF;
 706   1              OneTime[0].cdat[4] = 0xFF;
 707   1              OneTime[0].cdat[5] = 0xFF;
 708   1              OneTime[0].cdat[6] = 0xFF;
 709   1              OneTime[0].cdat[7] = 0xFF;
 710   1              OneTime[1].cdat[0] = 0x88;      // values (ORed)
 711   1              OneTime[1].cdat[1] = 0x99;
 712   1              OneTime[1].cdat[2] = 0xAA;
 713   1              OneTime[1].cdat[3] = 0xBB;
 714   1              OneTime[1].cdat[4] = 0xCC;
 715   1              OneTime[1].cdat[5] = 0xDD;
 716   1              OneTime[1].cdat[6] = 0xEE;
 717   1              OneTime[1].cdat[7] = 0xFF;
 718   1      // configure Tx output caused by above Recieved message
 719   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
 720   1              RxMessageConfig2(index,1,0x6E3,OneTime[0].cdat,OneTime[1].cdat,8,1);
 721   1      
 722   1      
 723   1      // Detect and set for English
 724   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 725   1              OneTime[0].cdat[1] = 0xFF;
 726   1              OneTime[0].cdat[2] = 0xFF;      
 727   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 728   1              OneTime[1].cdat[1] = 3;
 729   1              OneTime[1].cdat[2] = 1;         // this byte must match
 730   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 731   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 732   1              OneTime[0].cdat[1] = 0xFF;
 733   1              OneTime[0].cdat[2] = 0xFF;      
 734   1              OneTime[0].cdat[3] = 0xFF;
 735   1              OneTime[0].cdat[4] = 0xFF;
 736   1              OneTime[0].cdat[5] = 0xFF;
 737   1              OneTime[0].cdat[6] = 0x0;       // clear
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 13  

 738   1              OneTime[0].cdat[7] = 0xFF;
 739   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 740   1              OneTime[1].cdat[1] = 0;
 741   1              OneTime[1].cdat[2] = 0;
 742   1              OneTime[1].cdat[3] = 0;
 743   1              OneTime[1].cdat[4] = 0;
 744   1              OneTime[1].cdat[5] = 0;
 745   1              OneTime[1].cdat[6] = 8;         // write
 746   1              OneTime[1].cdat[7] = 0;         // note altercount = 0 means permanant
 747   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 748   1      
 749   1      // Detect and set for spa
 750   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 751   1              OneTime[0].cdat[1] = 0xFF;
 752   1              OneTime[0].cdat[2] = 0xFF;      
 753   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 754   1              OneTime[1].cdat[1] = 3;
 755   1              OneTime[1].cdat[2] = 4;         // this byte must match
 756   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 757   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 758   1              OneTime[0].cdat[1] = 0xFF;
 759   1              OneTime[0].cdat[2] = 0xFF;      
 760   1              OneTime[0].cdat[3] = 0xFF;
 761   1              OneTime[0].cdat[4] = 0xFF;
 762   1              OneTime[0].cdat[5] = 0xFF;
 763   1              OneTime[0].cdat[6] = 0x0;       // clear
 764   1              OneTime[0].cdat[7] = 0xFF;
 765   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 766   1              OneTime[1].cdat[1] = 0;
 767   1              OneTime[1].cdat[2] = 0;
 768   1              OneTime[1].cdat[3] = 0;
 769   1              OneTime[1].cdat[4] = 0;
 770   1              OneTime[1].cdat[5] = 0;
 771   1              OneTime[1].cdat[6] = 0x20;      // write
 772   1              OneTime[1].cdat[7] = 0;
 773   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 774   1      
 775   1      // Detect and set for ger
 776   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 777   1              OneTime[0].cdat[1] = 0xFF;
 778   1              OneTime[0].cdat[2] = 0xFF;      
 779   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 780   1              OneTime[1].cdat[1] = 3;
 781   1              OneTime[1].cdat[2] = 0;         // this byte must match
 782   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 783   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 784   1              OneTime[0].cdat[1] = 0xFF;
 785   1              OneTime[0].cdat[2] = 0xFF;      
 786   1              OneTime[0].cdat[3] = 0xFF;
 787   1              OneTime[0].cdat[4] = 0xFF;
 788   1              OneTime[0].cdat[5] = 0xFF;
 789   1              OneTime[0].cdat[6] = 0x0;       // clear
 790   1              OneTime[0].cdat[7] = 0xFF;
 791   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 792   1              OneTime[1].cdat[1] = 0;
 793   1              OneTime[1].cdat[2] = 0;
 794   1              OneTime[1].cdat[3] = 0;
 795   1              OneTime[1].cdat[4] = 0;
 796   1              OneTime[1].cdat[5] = 0;
 797   1              OneTime[1].cdat[6] = 0;         // write
 798   1              OneTime[1].cdat[7] = 0;
 799   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 14  

 800   1      
 801   1      // Detect and set for fre
 802   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 803   1              OneTime[0].cdat[1] = 0xFF;
 804   1              OneTime[0].cdat[2] = 0xFF;      
 805   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 806   1              OneTime[1].cdat[1] = 3;
 807   1              OneTime[1].cdat[2] = 2;         // this byte must match
 808   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 809   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 810   1              OneTime[0].cdat[1] = 0xFF;
 811   1              OneTime[0].cdat[2] = 0xFF;      
 812   1              OneTime[0].cdat[3] = 0xFF;
 813   1              OneTime[0].cdat[4] = 0xFF;
 814   1              OneTime[0].cdat[5] = 0xFF;
 815   1              OneTime[0].cdat[6] = 0x0;       // clear
 816   1              OneTime[0].cdat[7] = 0xFF;
 817   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 818   1              OneTime[1].cdat[1] = 0;
 819   1              OneTime[1].cdat[2] = 0;
 820   1              OneTime[1].cdat[3] = 0;
 821   1              OneTime[1].cdat[4] = 0;
 822   1              OneTime[1].cdat[5] = 0;
 823   1              OneTime[1].cdat[6] = 0x10;      // write
 824   1              OneTime[1].cdat[7] = 0;
 825   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 826   1      
 827   1      // Detect and set for ita
 828   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 829   1              OneTime[0].cdat[1] = 0xFF;
 830   1              OneTime[0].cdat[2] = 0xFF;      
 831   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 832   1              OneTime[1].cdat[1] = 3;
 833   1              OneTime[1].cdat[2] = 3;         // this byte must match
 834   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 835   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 836   1              OneTime[0].cdat[1] = 0xFF;
 837   1              OneTime[0].cdat[2] = 0xFF;      
 838   1              OneTime[0].cdat[3] = 0xFF;
 839   1              OneTime[0].cdat[4] = 0xFF;
 840   1              OneTime[0].cdat[5] = 0xFF;
 841   1              OneTime[0].cdat[6] = 0x0;       // clear
 842   1              OneTime[0].cdat[7] = 0xFF;
 843   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 844   1              OneTime[1].cdat[1] = 0;
 845   1              OneTime[1].cdat[2] = 0;
 846   1              OneTime[1].cdat[3] = 0;
 847   1              OneTime[1].cdat[4] = 0;
 848   1              OneTime[1].cdat[5] = 0;
 849   1              OneTime[1].cdat[6] = 0x60;      // write
 850   1              OneTime[1].cdat[7] = 0;
 851   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 852   1      
 853   1      // Detect and set for jap
 854   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 855   1              OneTime[0].cdat[1] = 0xFF;
 856   1              OneTime[0].cdat[2] = 0xFF;      
 857   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 858   1              OneTime[1].cdat[1] = 3;
 859   1              OneTime[1].cdat[2] = 5;         // this byte must match
 860   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 861   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 15  

 862   1              OneTime[0].cdat[1] = 0xFF;
 863   1              OneTime[0].cdat[2] = 0xFF;      
 864   1              OneTime[0].cdat[3] = 0xFF;
 865   1              OneTime[0].cdat[4] = 0xFF;
 866   1              OneTime[0].cdat[5] = 0xFF;
 867   1              OneTime[0].cdat[6] = 0x0;       // clear
 868   1              OneTime[0].cdat[7] = 0xFF;
 869   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 870   1              OneTime[1].cdat[1] = 0;
 871   1              OneTime[1].cdat[2] = 0;
 872   1              OneTime[1].cdat[3] = 0;
 873   1              OneTime[1].cdat[4] = 0;
 874   1              OneTime[1].cdat[5] = 0;
 875   1              OneTime[1].cdat[6] = 0x50;      // write
 876   1              OneTime[1].cdat[7] = 0;
 877   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 878   1      
 879   1      // Detect and set for chs
 880   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 881   1              OneTime[0].cdat[1] = 0xFF;
 882   1              OneTime[0].cdat[2] = 0xFF;      
 883   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 884   1              OneTime[1].cdat[1] = 3;
 885   1              OneTime[1].cdat[2] = 9;         // this byte must match
 886   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 887   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 888   1              OneTime[0].cdat[1] = 0xFF;
 889   1              OneTime[0].cdat[2] = 0xFF;      
 890   1              OneTime[0].cdat[3] = 0xFF;
 891   1              OneTime[0].cdat[4] = 0xFF;
 892   1              OneTime[0].cdat[5] = 0xFF;
 893   1              OneTime[0].cdat[6] = 0x0;       // clear
 894   1              OneTime[0].cdat[7] = 0xFF;
 895   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 896   1              OneTime[1].cdat[1] = 0;
 897   1              OneTime[1].cdat[2] = 0;
 898   1              OneTime[1].cdat[3] = 0;
 899   1              OneTime[1].cdat[4] = 0;
 900   1              OneTime[1].cdat[5] = 0;
 901   1              OneTime[1].cdat[6] = 0x48;      // write
 902   1              OneTime[1].cdat[7] = 0;
 903   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 904   1      
 905   1      // Detect and set for cht
 906   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
 907   1              OneTime[0].cdat[1] = 0xFF;
 908   1              OneTime[0].cdat[2] = 0xFF;      
 909   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
 910   1              OneTime[1].cdat[1] = 3;
 911   1              OneTime[1].cdat[2] = 0xE;       // this byte must match
 912   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
 913   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
 914   1              OneTime[0].cdat[1] = 0xFF;
 915   1              OneTime[0].cdat[2] = 0xFF;      
 916   1              OneTime[0].cdat[3] = 0xFF;
 917   1              OneTime[0].cdat[4] = 0xFF;
 918   1              OneTime[0].cdat[5] = 0xFF;
 919   1              OneTime[0].cdat[6] = 0x0;       // clear
 920   1              OneTime[0].cdat[7] = 0xFF;
 921   1              OneTime[1].cdat[0] = 0;         // values (ORed)
 922   1              OneTime[1].cdat[1] = 0;
 923   1              OneTime[1].cdat[2] = 0;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 16  

 924   1              OneTime[1].cdat[3] = 0;
 925   1              OneTime[1].cdat[4] = 0;
 926   1              OneTime[1].cdat[5] = 0;
 927   1              OneTime[1].cdat[6] = 0x90;      // write
 928   1              OneTime[1].cdat[7] = 0;
 929   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
 930   1      
 931   1              // Configure Relay's
 932   1              RelayCnf[3] = REL_IGN | 1 | REL_NOT;    // relay 4 comes on with Ignition switch setting not 1
 933   1              //RelayCnf[2] = REL_BUTT | 1 | REL_TOG; // relay 3 toggles with button 1
 934   1              //RelayCnf[1] = REL_RX | 0 | REL_PULSE; // relay 2 with first (0) rxtrap configured
 935   1              //RelayCnf[0] = REL_TX | 3 | REL_PULSE; // relay 1 with 4th (3) TxMesg configured
 936   1      
 937   1      /*************************************************************************
 938   1              User running loop 
 939   1      **************************************************************************/
 940   1              cnt = 0;
 941   1              counter =0;
 942   1              while(!(keyChange & 0xF)) 
 943   1              {
 944   2                      if (RxCAN0)             // new message to process
 945   2                      {
 946   3                              for (index = 1 ; index < RX0BUFFERS && rxframe0[index].MsgNum>=RX0BUFFERS ; index++);
 947   3      
 948   3                              if (index < RX0BUFFERS)
 949   3                              {
 950   4                                      ProcessRx(0,index);
 951   4                                      rxframe0[index].MsgNum = 0;
 952   4                              }
 953   3                              RxCAN0 = 0;
 954   3                      }
 955   2                      if (RxCAN1)             // new message to process
 956   2                      {
 957   3                              error = CAN1readStatus();
 958   3      
 959   3                              index = RX1BUFFERS;
 960   3                              index1 = RX1BUFFERS;
 961   3                              if (error & MCP_RX1IF)
 962   3                                      index1 = CAN1read_canMsg( MCP_READ_RX1 );        
 963   3                              if (error & MCP_RX0IF)
 964   3                                      index = CAN1read_canMsg( MCP_READ_RX0 );        
 965   3                              if (error = CAN1readRegister(MCP_EFLG))
 966   3                              {
 967   4                                      ErrCnt++;
 968   4                                      AlterMessageByte(1,0x6E2,7,1,ErrCnt,0);
 969   4      
 970   4                                      if (error & MCP_EFLG_RX1OVR)
 971   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX1OVR,0);
 972   4                                      if (error & MCP_EFLG_RX0OVR)
 973   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX0OVR,0);
 974   4                              }
 975   3      
 976   3                              // clear int flags
 977   3                              IE0 = 0;                                        // clear IE0 flag re-enabling interupt
 978   3                              RxCAN1 = 0;                                     // clear my flag interupt occured
 979   3                              EX0 = 1;                                        // enable CAN1 interupt
 980   3      
 981   3                              if (index < RX1BUFFERS)                         // process recieved message from Rx0
 982   3                              {
 983   4                                      ProcessRx(1,index);             // CAN1 messages
 984   4                              }
 985   3                              if (index1 < RX1BUFFERS)                        // process recieved message from Rx1
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 17  

 986   3                              {
 987   4                                      ProcessRx(1,index1);
 988   4                              }
 989   3                      }
 990   2      
 991   2                      if (StartTicks + ONESEC < msticks )     // every second
 992   2                      {
 993   3                              StartTicks = msticks;
 994   3                              LED1 ^= 1;
 995   3      
 996   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
 997   3                              if (index1 < TXBUFFS)                           // empty one time available
 998   3                              {
 999   4                                      OneTime[index1].cdat[0] = (U8)(keys>>24);
1000   4                                      OneTime[index1].cdat[1] = (U8)(keys>>16);
1001   4                                      OneTime[index1].cdat[2] = (U8)(keys>>8);
1002   4                                      OneTime[index1].cdat[3] = (U8)keys;
1003   4                                      OneTime[index1].cdat[4] = CAN1readStatus();
1004   4                                      OneTime[index1].cdat[5] = CAN1readRxStat();
1005   4                                      OneTime[index1].cdat[6] = CAN1readRegister(MCP_CANSTAT);
1006   4                                      OneTime[index1].cdat[7] = CAN1readRegister(MCP_CANINTF);
1007   4                                      AlterMessageByte(0,0x6EA,0,OneTime[index1].cdat,8,1);
1008   4                              }
1009   3      
1010   3                              // VIN
1011   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1012   3                              if (index1 < TXBUFFS)                           // empty one time available
1013   3                              {
1014   4                                      switch (vin++)
1015   4                                      {
1016   5                                              case 0:
1017   5                                                      OneTime[index1].cdat[0] = 0;
1018   5                                                      for (index = 0 ; index < 7 ; index++)
1019   5                                                              OneTime[index1].cdat[1+index] = VIN[index];
1020   5                                                      break;
1021   5                                              case 1:
1022   5                                                      OneTime[index1].cdat[0] = 1;
1023   5                                                      for (index = 7 ; index < 14 ; index++)
1024   5                                                              OneTime[index1].cdat[index-6] = VIN[index];
1025   5                                                      break;
1026   5                                              case 2:
1027   5                                                      OneTime[index1].cdat[0] = 2;
1028   5                                                      for (index = 14 ; index < 17 ; index++)
1029   5                                                              OneTime[index1].cdat[index-13] = VIN[index];
1030   5                                                      vin = 0;
1031   5                                                      break;
1032   5                                      }
1033   4                                      AlterMessageByte(0,0x3D3,0,OneTime[index1].cdat,8,0);
1034   4                              }
1035   3      
1036   3                              if (counter++ >= 9)     // test every 10 seconds alter 6E2 message
1037   3                              {
1038   4                                      for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1039   4                                      if (index1 < TXBUFFS)                           // empty one time available
1040   4                                      {
1041   5                                              OneTime[index1].cdat[0] = cnt++;
1042   5                                              AlterMessageByte(1,0x6E2,6,OneTime[index1].cdat,1,2);
1043   5                                              counter = 0;
1044   5                                      }
1045   4                              }
1046   3                      }
1047   2      
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 18  

1048   2      
1049   2                      if (RelayChange)
1050   2                              CheckRelay();
1051   2      
1052   2                      // check for buttons pressed and process
1053   2                      if (keyChange & 0xFFFFF00)      // At least one Buttons changed state
1054   2                      {
1055   3                              CheckButts();                   // SimpleButton Check
1056   3      
1057   3                              keyChange &= (U32)((BUTTONMASK<<8) & 0xFF);     // clear unused buttons
1058   3                      }
1059   2      
1060   2      
1061   2                      if (keyChange & 0xF0)           // Ignition change
1062   2                      {
1063   3                              // check if a relay is set to Ignition change
1064   3                              for (index1 = 0 ; index1 < 4; index1++){
1065   4                                      if ((RelayCnf[index1] & 0xF00) == REL_IGN)      // Relay controled by IGN select
1066   4                                      {
1067   5                                              if ((RelayCnf[index1]&0xFF) == ((keys>>4)&0xF)) // matching Select
1068   5                                                      RelayChange |= 1<<index1;                       // flag for relay "on" change
1069   5                                              else
1070   5                                                      RelayChange |= 0x10<<index1;            // flag for relay "off" change
1071   5                                      }
1072   4                              }
1073   3      
1074   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
1075   3                              if (index1 < TXBUFFS)                           // empty one time available
1076   3                              {
1077   4                                      IGN_OFF = 0;                    // default IGN_OFF flag to off
1078   4                                      switch(keys & 0xF0)
1079   4                                      {
1080   5                                              case 0x10:      // IGN_OFF
1081   5                                                      // ID 190, alter byte 0,1 
1082   5                                                      OneTime[index1].cdat[0] = 0x00;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1083   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1084   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1085   5      
1086   5                                                      // ID 98, alter bytes 2,3  
1087   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1088   5                                                      OneTime[index1].cdat[1] = 0x0;
1089   5                                                      OneTime[index1].cdat[2] = 0x0;
1090   5                                                      OneTime[index1].cdat[3] = 0x0;
1091   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1092   5                                                      IGN_OFF = 1;    // TURN on IGN_OFF flag
1093   5                                                      break;
1094   5                                              case 0x20:      // IGN_ACC
1095   5                                                      // ID 190, alter byte 0,1 
1096   5                                                      OneTime[index1].cdat[0] = 0x03;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1097   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1098   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1099   5      
1100   5                                                      // ID 98, alter bytes 2,3  
1101   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1102   5                                                      OneTime[index1].cdat[1] = 0x0;
1103   5                                                      OneTime[index1].cdat[2] = 0x0;
1104   5                                                      OneTime[index1].cdat[3] = 0x0;
1105   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1106   5                                                      break;
1107   5                                              case 0x30:      // IGN_START
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 19  

1108   5                                                      // ID 190, alter byte 0,1 
1109   5                                                      OneTime[index1].cdat[0] = 0x05;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1110   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1111   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1112   5      
1113   5                                                      // ID 98, alter bytes 2,3  
1114   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1115   5                                                      OneTime[index1].cdat[1] = 0x0;
1116   5                                                      OneTime[index1].cdat[2] = 0x0;
1117   5                                                      OneTime[index1].cdat[3] = 0x0;
1118   5                                                      AlterMessageByte(0,0x098,2,OneTime[index1].cdat,4,0);
1119   5                                                      break;
1120   5                                              case 0x40:      // IGN_RUN_0
1121   5                                                      // ID 190, alter byte 0,1 
1122   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1123   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1124   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1125   5      
1126   5                                                      // ID 98, alter bytes 2,3  
1127   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1128   5                                                      OneTime[index1].cdat[1] = 0x0;
1129   5                                                      OneTime[index1].cdat[2] = 0x0;
1130   5                                                      OneTime[index1].cdat[3] = 0x0;
1131   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1132   5                                                      break;
1133   5                                              case 0x50:      // IGN_RUN_5
1134   5                                              // ID 190, alter byte 0,1 
1135   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1136   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1137   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1138   5      
1139   5                                                      // ID 98, alter bytes 2,3  
1140   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1141   5                                                      OneTime[index1].cdat[1] = 0x0;
1142   5                                                      OneTime[index1].cdat[2] = 0x0;
1143   5                                                      OneTime[index1].cdat[3] = 0x80;
1144   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1145   5                                                      break;
1146   5                                              case 0x60:      // IGN_RUN_10
1147   5                                              // ID 190, alter byte 0,1 
1148   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
1149   5                                                      OneTime[index1].cdat[1] = 0x22;                 //key in ignition
1150   5                                                      AlterMessageByte(0,0x190,0,OneTime[index1].cdat,2,0);
1151   5      
1152   5                                                      // ID 98, alter bytes 2,3  
1153   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
1154   5                                                      OneTime[index1].cdat[1] = 0x0;
1155   5                                                      OneTime[index1].cdat[2] = 0x0;
1156   5                                                      OneTime[index1].cdat[3] = 0xFD;
1157   5                                                      AlterMessageByte(0,0x098,0,OneTime[index1].cdat,4,0);
1158   5                                                      break;
1159   5                                              
1160   5                                              case 0x70:
1161   5                                                      break;
1162   5                                              case 0x80:
1163   5                                                      break;
1164   5                                      }
1165   4      
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 20  

1166   4                              keyChange &= ~0xF0;             // clear Ignition nibble
1167   4                              }
1168   3                      }
1169   2              }
1170   1      }
1171          void User2()    // program select 2, PNET
1172          {       
1173   1              U32 StartTicks = 0;
1174   1              U8  index,index1,ErrCnt,counter,vin,error, cnt;
1175   1              bit IGN_OFF=1;
1176   1      
1177   1              char VIN[17] = "1C3CCCCB7FN1124UC";
1178   1      
1179   1              error = 0;      ErrCnt=0;
1180   1      
1181   1      
1182   1      
1183   1      /***************************************************************************************
1184   1      ****************************************************************************************
1185   1              CAUTION WATCH XDATA BOUNDARIES.  NOT AUTOMATIC ITS UP TO YOU!!!!!!
1186   1      ****************************************************************************************
1187   1              // CODE CURRENTLY USES 809 xdata bytes.  THEREFORE STARTING CAN BE AT 0x32A
1188   1              // watch at compile the xdata bytes used. if xdata > 810d need to change below
1189   1              // xdata space ends at 0xFFF.
1190   1      ***************************************************************************************/
1191   1      //      Buttons = (BUTTABLE xdata *)0x32A;      // 20 buttons takes 32Abytes => 0x32A-0x4E1
1192   1              ButtCnt = 0;                                            // each Button = 20 bytes
1193   1      
1194   1      //      Mesgs = (MSGTABLE xdata *)0x4E2;        // 0x4E2-0x93F -> space for 43 Tx messages 
1195   1              MesgCnt = 0;                                            // each Mesgs = 26 bytes
1196   1      
1197   1      //      RxMesg = (RxMESG xdata *)0x940;         // 0x940-0xFF8 -> space for 43 Rx messages 
1198   1              RxCnt = 0;                                                      // each RxMesg = 40 bytes
1199   1      
1200   1      // AUTOMATED above some,
1201   1      // Make Sure XDATASPACE define follows compile output value  
1202   1      #define XDATASPACE 810          // starting free address
1203   1      
1204   1      /***************************************************************************************
1205   1      // Currently (809 xdata start) you get 43 Tx messages and 43 Rx message traps.  If you 
1206   1      // need more of one and less of the other you can manipulate the starting numbers below
1207   1      // to get it to work.
1208   1      // also note RX0 buff size is 32 messages on CAN0, and RX1 buff size is 16 for CAN1
1209   1      ***************************************************************************************/
1210   1              MaxMesgs = 45;                  // number of Tx message configs
1211   1              MaxRxTraps = 45;                // number of Rx message configs
1212   1              while(!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))    // 20 button configs  
1213   1              {
1214   2                      MaxRxTraps--;           // reduce Message buffers till it fits.
1215   2                      if (!MemManage(MAXBUTTONS,MaxMesgs,MaxRxTraps,XDATASPACE))
1216   2                              MaxMesgs--;             // reduce Message buffers till it fits
1217   2              }
1218   1      /**************************************************************************************/
1219   1      
1220   1      
1221   1      /*************************************************************************
1222   1              Repeating message setups
1223   1              example below-
1224   1              message ID 0x6E2 is created at rate of 500mSec on port 1 (C). With 8 bytes 
1225   1              of data, shown are it's defaults.
1226   1      **************************************************************************/
1227   1                      
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 21  

1228   1              OneTime[0].cdat[0] = 0;
1229   1              OneTime[0].cdat[1] = 0; 
1230   1              OneTime[0].cdat[2] = 0;
1231   1              OneTime[0].cdat[3] = 0;
1232   1              AddMessage(0,0x122,500,4,OneTime[0].cdat);  // CBC_I4 - IGN state
1233   1              
1234   1              OneTime[0].cdat[0] = 0;
1235   1              OneTime[0].cdat[1] = 0; 
1236   1              OneTime[0].cdat[2] = 0;
1237   1              OneTime[0].cdat[3] = 0;
1238   1              OneTime[0].cdat[4] = 0;
1239   1              OneTime[0].cdat[5] = 0;
1240   1              OneTime[0].cdat[6] = 0;
1241   1              OneTime[0].cdat[7] = 0;
1242   1              AddMessage(0,0x22D,950,8,OneTime[0].cdat);  // SWS_8 - Steering Wheel messages
1243   1              
1244   1              OneTime[0].cdat[0] = 0;
1245   1              OneTime[0].cdat[1] = 0; 
1246   1              OneTime[0].cdat[2] = 0;
1247   1              OneTime[0].cdat[3] = 0;
1248   1              OneTime[0].cdat[4] = 0;
1249   1              OneTime[0].cdat[5] = 0;
1250   1              OneTime[0].cdat[6] = 0;
1251   1              OneTime[0].cdat[7] = 0;
1252   1              AddMessage(0,0x273,1000,8,OneTime[0].cdat);  // ICS_KNOBS
1253   1              
1254   1              OneTime[0].cdat[0] = 0x18;
1255   1              OneTime[0].cdat[1] = 0x38;      
1256   1              OneTime[0].cdat[2] = 0x8B;
1257   1              OneTime[0].cdat[3] = 0;
1258   1              AddMessage(0,0x2C2,200,4,OneTime[0].cdat);  // CBC_I3
1259   1              
1260   1              OneTime[0].cdat[0] = 0;
1261   1              OneTime[0].cdat[1] = 0xEE;      
1262   1              OneTime[0].cdat[2] = 0xEE;
1263   1              OneTime[0].cdat[3] = 0x2E;
1264   1              OneTime[0].cdat[4] = 0;
1265   1              OneTime[0].cdat[5] = 0;
1266   1              OneTime[0].cdat[6] = 0;
1267   1              OneTime[0].cdat[7] = 0;
1268   1              AddMessage(0,0x2C5,2000,8,OneTime[0].cdat);  // EcuCfg16
1269   1              
1270   1              OneTime[0].cdat[0] = 0;
1271   1              OneTime[0].cdat[1] = 0; 
1272   1              OneTime[0].cdat[2] = 0;
1273   1              OneTime[0].cdat[3] = 0;
1274   1              OneTime[0].cdat[4] = 0;
1275   1              OneTime[0].cdat[5] = 0;
1276   1              OneTime[0].cdat[6] = 0;
1277   1              OneTime[0].cdat[7] = 0;
1278   1              AddMessage(0,0x2D3,1000,8,OneTime[0].cdat);  // ICS_MSG
1279   1              
1280   1              OneTime[0].cdat[0] = 0;
1281   1              OneTime[0].cdat[1] = 0x01;      
1282   1              OneTime[0].cdat[2] = 0xC8;
1283   1              OneTime[0].cdat[3] = 0x18;
1284   1              OneTime[0].cdat[4] = 0;
1285   1              OneTime[0].cdat[5] = 0;
1286   1              OneTime[0].cdat[6] = 0;
1287   1              OneTime[0].cdat[7] = 0x01;
1288   1              AddMessage(0,0x2FA,500,8,OneTime[0].cdat);  // CBC_I2
1289   1              
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 22  

1290   1              OneTime[0].cdat[0] = 0;
1291   1              OneTime[0].cdat[1] = 0; 
1292   1              OneTime[0].cdat[2] = 0;
1293   1              OneTime[0].cdat[3] = 0;
1294   1              OneTime[0].cdat[4] = 0;
1295   1              OneTime[0].cdat[5] = 0x83;
1296   1              OneTime[0].cdat[6] = 0;
1297   1              OneTime[0].cdat[7] = 0;
1298   1              AddMessage(0,0x305,1000,8,OneTime[0].cdat);  // CBC_I6
1299   1              
1300   1              OneTime[0].cdat[0] = 0x19;
1301   1              OneTime[0].cdat[1] = 0; 
1302   1              OneTime[0].cdat[2] = 0;
1303   1              OneTime[0].cdat[3] = 0x01;
1304   1              OneTime[0].cdat[4] = 0;
1305   1              OneTime[0].cdat[5] = 0;
1306   1              OneTime[0].cdat[6] = 0;
1307   1              OneTime[0].cdat[7] = 0;
1308   1              AddMessage(0,0x381,2000,8,OneTime[0].cdat);  // VehCfg7
1309   1              
1310   1              OneTime[0].cdat[0] = 0;
1311   1              OneTime[0].cdat[1] = 0x01;      
1312   1              OneTime[0].cdat[2] = 0x4C;
1313   1              OneTime[0].cdat[3] = 0;
1314   1              OneTime[0].cdat[4] = 0;
1315   1              OneTime[0].cdat[5] = 0;
1316   1              AddMessage(0,0x3A2,1000,6,OneTime[0].cdat);  // CBC_I5
1317   1              
1318   1              OneTime[0].cdat[0] = 0x01;
1319   1              OneTime[0].cdat[1] = 0; 
1320   1              OneTime[0].cdat[2] = 0x80;
1321   1              OneTime[0].cdat[3] = 0;
1322   1              OneTime[0].cdat[4] = 0;
1323   1              OneTime[0].cdat[5] = 0xFF;
1324   1              OneTime[0].cdat[6] = 0xFF;
1325   1              OneTime[0].cdat[7] = 0;
1326   1              AddMessage(0,0x3B2,500,8,OneTime[0].cdat);  // CBC_I1
1327   1              
1328   1              OneTime[0].cdat[0] = 0x3E;
1329   1              OneTime[0].cdat[1] = 0x1E;      
1330   1              OneTime[0].cdat[2] = 0x1E;
1331   1              OneTime[0].cdat[3] = 0;
1332   1              OneTime[0].cdat[4] = 0x03;
1333   1              OneTime[0].cdat[5] = 0x01;
1334   1              OneTime[0].cdat[6] = 0x91;
1335   1              OneTime[0].cdat[7] = 0x01;
1336   1              AddMessage(0,0x3DE,500,8,OneTime[0].cdat);  // CBC_CFG1
1337   1              
1338   1              OneTime[0].cdat[0] = 0;
1339   1              OneTime[0].cdat[1] = 0; 
1340   1              OneTime[0].cdat[2] = 0;
1341   1              OneTime[0].cdat[3] = 0;
1342   1              OneTime[0].cdat[4] = 0;
1343   1              OneTime[0].cdat[5] = 0;
1344   1              OneTime[0].cdat[6] = 0;
1345   1              OneTime[0].cdat[7] = 0;
1346   1              AddMessage(0,0x3E0,1000,8,OneTime[0].cdat);  // VIN
1347   1              
1348   1              OneTime[0].cdat[0] = 0x41;
1349   1              OneTime[0].cdat[1] = 0x29;      
1350   1              OneTime[0].cdat[2] = 0xA2;
1351   1              OneTime[0].cdat[3] = 0x15;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 23  

1352   1              OneTime[0].cdat[4] = 0x1E;
1353   1              OneTime[0].cdat[5] = 0x80;
1354   1              OneTime[0].cdat[6] = 0xA2;
1355   1              OneTime[0].cdat[7] = 0x10;
1356   1              AddMessage(0,0x3E8,2000,8,OneTime[0].cdat);  // VehCfg1
1357   1              
1358   1              OneTime[0].cdat[0] = 0x01;
1359   1              OneTime[0].cdat[1] = 0; 
1360   1              OneTime[0].cdat[2] = 0x06;
1361   1              OneTime[0].cdat[3] = 0x9E;
1362   1              OneTime[0].cdat[4] = 0x20;
1363   1              OneTime[0].cdat[5] = 0x20;
1364   1              OneTime[0].cdat[6] = 0x20;
1365   1              OneTime[0].cdat[7] = 0x20;
1366   1              AddMessage(0,0x3E9,2000,8,OneTime[0].cdat);  // VehCfg2
1367   1              
1368   1              OneTime[0].cdat[0] = 0x41;
1369   1              OneTime[0].cdat[1] = 0x0D;      
1370   1              OneTime[0].cdat[2] = 0x22;
1371   1              OneTime[0].cdat[3] = 0x48;
1372   1              OneTime[0].cdat[4] = 0x80;
1373   1              OneTime[0].cdat[5] = 0x24;
1374   1              OneTime[0].cdat[6] = 0x03;
1375   1              OneTime[0].cdat[7] = 0x40;
1376   1              AddMessage(0,0x3EA,2000,8,OneTime[0].cdat);  // VehCfg3
1377   1              
1378   1              OneTime[0].cdat[0] = 0x40;
1379   1              OneTime[0].cdat[1] = 0; 
1380   1              OneTime[0].cdat[2] = 0;
1381   1              OneTime[0].cdat[3] = 0;
1382   1              OneTime[0].cdat[4] = 0;
1383   1              OneTime[0].cdat[5] = 0;
1384   1              OneTime[0].cdat[6] = 0x08;
1385   1              OneTime[0].cdat[7] = 0xC6;
1386   1              AddMessage(0,0x3EB,2000,8,OneTime[0].cdat);  // VehCfg4
1387   1              
1388   1              OneTime[0].cdat[0] = 0x45;
1389   1              OneTime[0].cdat[1] = 0x02;      
1390   1              OneTime[0].cdat[2] = 0x1D;
1391   1              OneTime[0].cdat[3] = 0x20;
1392   1              OneTime[0].cdat[4] = 0x1D;
1393   1              OneTime[0].cdat[5] = 0xA0;
1394   1              OneTime[0].cdat[6] = 0;
1395   1              OneTime[0].cdat[7] = 0x03;
1396   1              AddMessage(0,0x3F2,2000,8,OneTime[0].cdat);  // EcuCfg3
1397   1              
1398   1              OneTime[0].cdat[0] = 0x01;
1399   1              OneTime[0].cdat[1] = 0; 
1400   1              OneTime[0].cdat[2] = 0;
1401   1              OneTime[0].cdat[3] = 0;
1402   1              OneTime[0].cdat[4] = 0;
1403   1              OneTime[0].cdat[5] = 0;
1404   1              OneTime[0].cdat[6] = 0;
1405   1              OneTime[0].cdat[7] = 0x20;
1406   1              AddMessage(0,0x44A,2000,8,OneTime[0].cdat);  // VehCfg5
1407   1              
1408   1              OneTime[0].cdat[0] = 0x01;
1409   1              OneTime[0].cdat[1] = 0; 
1410   1              OneTime[0].cdat[2] = 0;
1411   1              OneTime[0].cdat[3] = 0;
1412   1              OneTime[0].cdat[4] = 0;
1413   1              OneTime[0].cdat[5] = 0;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 24  

1414   1              OneTime[0].cdat[6] = 0;
1415   1              OneTime[0].cdat[7] = 0;
1416   1              AddMessage(0,0x44C,2000,8,OneTime[0].cdat);  // VehCfg6
1417   1              
1418   1              OneTime[0].cdat[0] = 0;
1419   1              OneTime[0].cdat[1] = 0; 
1420   1              OneTime[0].cdat[2] = 0;
1421   1              OneTime[0].cdat[3] = 0;
1422   1              OneTime[0].cdat[4] = 0;
1423   1              OneTime[0].cdat[5] = 0;
1424   1              OneTime[0].cdat[6] = 0;
1425   1              OneTime[0].cdat[7] = 0;
1426   1              AddMessage(0,0x322,100,8,OneTime[0].cdat);  // VehCfg1
1427   1      
1428   1      
1429   1      /*************************************************************************
1430   1              Button setup
1431   1              example below -
1432   1              pressing button 1 causes byte 5 of message 0x6E2 to be altered to 0xAA 
1433   1              for the next 5 outputs. The mask clears byte 5 leaving the rest alone.  
1434   1              The value (0xAA) is ORed into byte 5.
1435   1      **************************************************************************/
1436   1              #define BUTTONMASK 0xF  // only button 1 defined (bit 1) 
1437   1      
1438   1              // Volume Up
1439   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1440   1              OneTime[0].cdat[1] = 0xFF;
1441   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1442   1              OneTime[0].cdat[3] = 0xFF;
1443   1              OneTime[0].cdat[4] = 0xFF;
1444   1              OneTime[0].cdat[5] = 0;         
1445   1              OneTime[0].cdat[6] = 0xFF;
1446   1              OneTime[0].cdat[7] = 0xFF;
1447   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1448   1              OneTime[1].cdat[1] = 0;
1449   1              OneTime[1].cdat[2] = 0;
1450   1              OneTime[1].cdat[3] = 0;
1451   1              OneTime[1].cdat[4] = 0;
1452   1              OneTime[1].cdat[5] = 0x08;
1453   1              OneTime[1].cdat[6] = 0;
1454   1              OneTime[1].cdat[7] = 0;
1455   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1456   1              SimpleButtonConfig(19,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1457   1      
1458   1              // Volume Down
1459   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1460   1              OneTime[0].cdat[1] = 0xFF;
1461   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1462   1              OneTime[0].cdat[3] = 0xFF;
1463   1              OneTime[0].cdat[4] = 0xFF;
1464   1              OneTime[0].cdat[5] = 0;         
1465   1              OneTime[0].cdat[6] = 0xFF;
1466   1              OneTime[0].cdat[7] = 0xFF;
1467   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1468   1              OneTime[1].cdat[1] = 0;
1469   1              OneTime[1].cdat[2] = 0;
1470   1              OneTime[1].cdat[3] = 0;
1471   1              OneTime[1].cdat[4] = 0;
1472   1              OneTime[1].cdat[5] = 0x20;
1473   1              OneTime[1].cdat[6] = 0;
1474   1              OneTime[1].cdat[7] = 0;
1475   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 25  

1476   1              SimpleButtonConfig(9,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1477   1      
1478   1              // Mode
1479   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1480   1              OneTime[0].cdat[1] = 0xFF;
1481   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1482   1              OneTime[0].cdat[3] = 0xFF;
1483   1              OneTime[0].cdat[4] = 0xFF;
1484   1              OneTime[0].cdat[5] = 0;         
1485   1              OneTime[0].cdat[6] = 0xFF;
1486   1              OneTime[0].cdat[7] = 0xFF;
1487   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1488   1              OneTime[1].cdat[1] = 0;
1489   1              OneTime[1].cdat[2] = 0;
1490   1              OneTime[1].cdat[3] = 0;
1491   1              OneTime[1].cdat[4] = 0;
1492   1              OneTime[1].cdat[5] = 0x80;
1493   1              OneTime[1].cdat[6] = 0;
1494   1              OneTime[1].cdat[7] = 0;
1495   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1496   1              SimpleButtonConfig(18,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1497   1      
1498   1              // Preset
1499   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1500   1              OneTime[0].cdat[1] = 0xFF;
1501   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1502   1              OneTime[0].cdat[3] = 0;
1503   1              OneTime[0].cdat[4] = 0xFF;
1504   1              OneTime[0].cdat[5] = 0xFF;              
1505   1              OneTime[0].cdat[6] = 0xFF;
1506   1              OneTime[0].cdat[7] = 0xFF;
1507   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1508   1              OneTime[1].cdat[1] = 0;
1509   1              OneTime[1].cdat[2] = 0;
1510   1              OneTime[1].cdat[3] = 0x08;
1511   1              OneTime[1].cdat[4] = 0;
1512   1              OneTime[1].cdat[5] = 0;
1513   1              OneTime[1].cdat[6] = 0;
1514   1              OneTime[1].cdat[7] = 0;
1515   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1516   1              SimpleButtonConfig(8,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1517   1      
1518   1              // Seek Up
1519   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1520   1              OneTime[0].cdat[1] = 0xFF;
1521   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1522   1              OneTime[0].cdat[3] = 0xFF;
1523   1              OneTime[0].cdat[4] = 0;
1524   1              OneTime[0].cdat[5] = 0xFF;              
1525   1              OneTime[0].cdat[6] = 0xFF;
1526   1              OneTime[0].cdat[7] = 0xFF;
1527   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1528   1              OneTime[1].cdat[1] = 0;
1529   1              OneTime[1].cdat[2] = 0;
1530   1              OneTime[1].cdat[3] = 0;
1531   1              OneTime[1].cdat[4] = 0x02;
1532   1              OneTime[1].cdat[5] = 0;
1533   1              OneTime[1].cdat[6] = 0;
1534   1              OneTime[1].cdat[7] = 0;
1535   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1536   1              SimpleButtonConfig(17,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1537   1      
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 26  

1538   1              // Seek Down
1539   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1540   1              OneTime[0].cdat[1] = 0xFF;
1541   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1542   1              OneTime[0].cdat[3] = 0xFF;
1543   1              OneTime[0].cdat[4] = 0;
1544   1              OneTime[0].cdat[5] = 0xFF;              
1545   1              OneTime[0].cdat[6] = 0xFF;
1546   1              OneTime[0].cdat[7] = 0xFF;
1547   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1548   1              OneTime[1].cdat[1] = 0;
1549   1              OneTime[1].cdat[2] = 0;
1550   1              OneTime[1].cdat[3] = 0;
1551   1              OneTime[1].cdat[4] = 0x08;
1552   1              OneTime[1].cdat[5] = 0;
1553   1              OneTime[1].cdat[6] = 0;
1554   1              OneTime[1].cdat[7] = 0;
1555   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1556   1              SimpleButtonConfig(7,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1557   1      
1558   1              // Phone Pickup
1559   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1560   1              OneTime[0].cdat[1] = 0xFF;
1561   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1562   1              OneTime[0].cdat[3] = 0xFF;
1563   1              OneTime[0].cdat[4] = 0;
1564   1              OneTime[0].cdat[5] = 0xFF;              
1565   1              OneTime[0].cdat[6] = 0xFF;
1566   1              OneTime[0].cdat[7] = 0xFF;
1567   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1568   1              OneTime[1].cdat[1] = 0;
1569   1              OneTime[1].cdat[2] = 0;
1570   1              OneTime[1].cdat[3] = 0;
1571   1              OneTime[1].cdat[4] = 0x80;
1572   1              OneTime[1].cdat[5] = 0;
1573   1              OneTime[1].cdat[6] = 0;
1574   1              OneTime[1].cdat[7] = 0;
1575   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1576   1              SimpleButtonConfig(16,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1577   1      
1578   1              // Phone Hangup
1579   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1580   1              OneTime[0].cdat[1] = 0xFF;
1581   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1582   1              OneTime[0].cdat[3] = 0;
1583   1              OneTime[0].cdat[4] = 0xFF;
1584   1              OneTime[0].cdat[5] = 0xFF;              
1585   1              OneTime[0].cdat[6] = 0xFF;
1586   1              OneTime[0].cdat[7] = 0xFF;
1587   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1588   1              OneTime[1].cdat[1] = 0;
1589   1              OneTime[1].cdat[2] = 0;
1590   1              OneTime[1].cdat[3] = 0x02;
1591   1              OneTime[1].cdat[4] = 0;
1592   1              OneTime[1].cdat[5] = 0;
1593   1              OneTime[1].cdat[6] = 0;
1594   1              OneTime[1].cdat[7] = 0;
1595   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1596   1              SimpleButtonConfig(6,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1597   1      
1598   1              // VR
1599   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 27  

1600   1              OneTime[0].cdat[1] = 0xFF;
1601   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1602   1              OneTime[0].cdat[3] = 0;
1603   1              OneTime[0].cdat[4] = 0xFF;
1604   1              OneTime[0].cdat[5] = 0xFF;              
1605   1              OneTime[0].cdat[6] = 0xFF;
1606   1              OneTime[0].cdat[7] = 0xFF;
1607   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1608   1              OneTime[1].cdat[1] = 0;
1609   1              OneTime[1].cdat[2] = 0;
1610   1              OneTime[1].cdat[3] = 0x20;
1611   1              OneTime[1].cdat[4] = 0;
1612   1              OneTime[1].cdat[5] = 0;
1613   1              OneTime[1].cdat[6] = 0;
1614   1              OneTime[1].cdat[7] = 0;
1615   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1616   1              SimpleButtonConfig(15,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1617   1      
1618   1              // Screen Off
1619   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1620   1              OneTime[0].cdat[1] = 0;
1621   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1622   1              OneTime[0].cdat[3] = 0xFF;
1623   1              OneTime[0].cdat[4] = 0xFF;
1624   1              OneTime[0].cdat[5] = 0xFF;              
1625   1              OneTime[0].cdat[6] = 0xFF;
1626   1              OneTime[0].cdat[7] = 0xFF;
1627   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1628   1              OneTime[1].cdat[1] = 0x10;
1629   1              OneTime[1].cdat[2] = 0;
1630   1              OneTime[1].cdat[3] = 0;
1631   1              OneTime[1].cdat[4] = 0;
1632   1              OneTime[1].cdat[5] = 0;
1633   1              OneTime[1].cdat[6] = 0;
1634   1              OneTime[1].cdat[7] = 0;
1635   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1636   1              SimpleButtonConfig(5,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
1637   1      
1638   1              // Mute
1639   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
1640   1              OneTime[0].cdat[1] = 0xFF;
1641   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1642   1              OneTime[0].cdat[3] = 0xFF;
1643   1              OneTime[0].cdat[4] = 0xFF;
1644   1              OneTime[0].cdat[5] = 0xFF;              
1645   1              OneTime[0].cdat[6] = 0xFF;
1646   1              OneTime[0].cdat[7] = 0xFF;
1647   1              OneTime[1].cdat[0] = 0x02;              // values (ORed)
1648   1              OneTime[1].cdat[1] = 0;
1649   1              OneTime[1].cdat[2] = 0;
1650   1              OneTime[1].cdat[3] = 0;
1651   1              OneTime[1].cdat[4] = 0;
1652   1              OneTime[1].cdat[5] = 0;
1653   1              OneTime[1].cdat[6] = 0;
1654   1              OneTime[1].cdat[7] = 0;
1655   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1656   1              SimpleButtonConfig(14,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
1657   1      
1658   1              // Back
1659   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1660   1              OneTime[0].cdat[1] = 0;
1661   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 28  

1662   1              OneTime[0].cdat[3] = 0xFF;
1663   1              OneTime[0].cdat[4] = 0xFF;
1664   1              OneTime[0].cdat[5] = 0xFF;              
1665   1              OneTime[0].cdat[6] = 0xFF;
1666   1              OneTime[0].cdat[7] = 0xFF;
1667   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1668   1              OneTime[1].cdat[1] = 0x01;
1669   1              OneTime[1].cdat[2] = 0;
1670   1              OneTime[1].cdat[3] = 0;
1671   1              OneTime[1].cdat[4] = 0;
1672   1              OneTime[1].cdat[5] = 0;
1673   1              OneTime[1].cdat[6] = 0;
1674   1              OneTime[1].cdat[7] = 0;
1675   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1676   1              SimpleButtonConfig(4,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
1677   1      
1678   1              // Browse/Enter
1679   1              OneTime[0].cdat[0] = 0; // mask bits (ANDed)
1680   1              OneTime[0].cdat[1] = 0xFF;
1681   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1682   1              OneTime[0].cdat[3] = 0xFF;
1683   1              OneTime[0].cdat[4] = 0xFF;
1684   1              OneTime[0].cdat[5] = 0xFF;              
1685   1              OneTime[0].cdat[6] = 0xFF;
1686   1              OneTime[0].cdat[7] = 0xFF;
1687   1              OneTime[1].cdat[0] = 0x01;              // values (ORed)
1688   1              OneTime[1].cdat[1] = 0;
1689   1              OneTime[1].cdat[2] = 0;
1690   1              OneTime[1].cdat[3] = 0;
1691   1              OneTime[1].cdat[4] = 0;
1692   1              OneTime[1].cdat[5] = 0;
1693   1              OneTime[1].cdat[6] = 0;
1694   1              OneTime[1].cdat[7] = 0;
1695   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1696   1              SimpleButtonConfig(13,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,1);
1697   1      /*
1698   1              // Screenshot
1699   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1700   1              OneTime[0].cdat[1] = 0xFF;
1701   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1702   1              OneTime[0].cdat[3] = 0xFF;
1703   1              OneTime[0].cdat[4] = 0;
1704   1              OneTime[0].cdat[5] = 0xFF;              
1705   1              OneTime[0].cdat[6] = 0xFF;
1706   1              OneTime[0].cdat[7] = 0xFF;
1707   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1708   1              OneTime[1].cdat[1] = 0;
1709   1              OneTime[1].cdat[2] = 0;
1710   1              OneTime[1].cdat[3] = 0;
1711   1              OneTime[1].cdat[4] = 0x80;
1712   1              OneTime[1].cdat[5] = 0;
1713   1              OneTime[1].cdat[6] = 0;
1714   1              OneTime[1].cdat[7] = 0;
1715   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1716   1              SimpleButtonConfig(3,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1717   1      
1718   1      */
1719   1              // ENG. Mode
1720   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1721   1              OneTime[0].cdat[1] = 0xFF;
1722   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1723   1              OneTime[0].cdat[3] = 0xFF;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 29  

1724   1              OneTime[0].cdat[4] = 0;
1725   1              OneTime[0].cdat[5] = 0xFF;              
1726   1              OneTime[0].cdat[6] = 0xFF;
1727   1              OneTime[0].cdat[7] = 0xFF;
1728   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1729   1              OneTime[1].cdat[1] = 0;
1730   1              OneTime[1].cdat[2] = 0;
1731   1              OneTime[1].cdat[3] = 0;
1732   1              OneTime[1].cdat[4] = 0xC0;
1733   1              OneTime[1].cdat[5] = 0;
1734   1              OneTime[1].cdat[6] = 0;
1735   1              OneTime[1].cdat[7] = 0;
1736   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1737   1              SimpleButtonConfig(12,0,0x5E2,OneTime[0].cdat,OneTime[1].cdat,12);
1738   1      /*
1739   1              // Dealer Mode
1740   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1741   1              OneTime[0].cdat[1] = 0xFF;
1742   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1743   1              OneTime[0].cdat[3] = 0xFF;
1744   1              OneTime[0].cdat[4] = 0;
1745   1              OneTime[0].cdat[5] = 0xFF;              
1746   1              OneTime[0].cdat[6] = 0xFF;
1747   1              OneTime[0].cdat[7] = 0xFF;
1748   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1749   1              OneTime[1].cdat[1] = 0;
1750   1              OneTime[1].cdat[2] = 0;
1751   1              OneTime[1].cdat[3] = 0;
1752   1              OneTime[1].cdat[4] = 0x80;
1753   1              OneTime[1].cdat[5] = 0;
1754   1              OneTime[1].cdat[6] = 0;
1755   1              OneTime[1].cdat[7] = 0;
1756   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1757   1              SimpleButtonConfig(2,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1758   1      
1759   1              // 911
1760   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1761   1              OneTime[0].cdat[1] = 0xFF;
1762   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1763   1              OneTime[0].cdat[3] = 0xFF;
1764   1              OneTime[0].cdat[4] = 0;
1765   1              OneTime[0].cdat[5] = 0xFF;              
1766   1              OneTime[0].cdat[6] = 0xFF;
1767   1              OneTime[0].cdat[7] = 0xFF;
1768   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1769   1              OneTime[1].cdat[1] = 0;
1770   1              OneTime[1].cdat[2] = 0;
1771   1              OneTime[1].cdat[3] = 0;
1772   1              OneTime[1].cdat[4] = 0x80;
1773   1              OneTime[1].cdat[5] = 0;
1774   1              OneTime[1].cdat[6] = 0;
1775   1              OneTime[1].cdat[7] = 0;
1776   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1777   1              SimpleButtonConfig(11,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1778   1      
1779   1              // Assist
1780   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1781   1              OneTime[0].cdat[1] = 0xFF;
1782   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1783   1              OneTime[0].cdat[3] = 0xFF;
1784   1              OneTime[0].cdat[4] = 0;
1785   1              OneTime[0].cdat[5] = 0xFF;              
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 30  

1786   1              OneTime[0].cdat[6] = 0xFF;
1787   1              OneTime[0].cdat[7] = 0xFF;
1788   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1789   1              OneTime[1].cdat[1] = 0;
1790   1              OneTime[1].cdat[2] = 0;
1791   1              OneTime[1].cdat[3] = 0;
1792   1              OneTime[1].cdat[4] = 0x80;
1793   1              OneTime[1].cdat[5] = 0;
1794   1              OneTime[1].cdat[6] = 0;
1795   1              OneTime[1].cdat[7] = 0;
1796   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1797   1              SimpleButtonConfig(1,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1798   1      
1799   1              // Door Ajar
1800   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1801   1              OneTime[0].cdat[1] = 0xFF;
1802   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1803   1              OneTime[0].cdat[3] = 0xFF;
1804   1              OneTime[0].cdat[4] = 0;
1805   1              OneTime[0].cdat[5] = 0xFF;              
1806   1              OneTime[0].cdat[6] = 0xFF;
1807   1              OneTime[0].cdat[7] = 0xFF;
1808   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1809   1              OneTime[1].cdat[1] = 0;
1810   1              OneTime[1].cdat[2] = 0;
1811   1              OneTime[1].cdat[3] = 0;
1812   1              OneTime[1].cdat[4] = 0x80;
1813   1              OneTime[1].cdat[5] = 0;
1814   1              OneTime[1].cdat[6] = 0;
1815   1              OneTime[1].cdat[7] = 0;
1816   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1817   1              SimpleButtonConfig(10,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1818   1      
1819   1              // Theft Alarm
1820   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1821   1              OneTime[0].cdat[1] = 0xFF;
1822   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1823   1              OneTime[0].cdat[3] = 0xFF;
1824   1              OneTime[0].cdat[4] = 0;
1825   1              OneTime[0].cdat[5] = 0xFF;              
1826   1              OneTime[0].cdat[6] = 0xFF;
1827   1              OneTime[0].cdat[7] = 0xFF;
1828   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1829   1              OneTime[1].cdat[1] = 0;
1830   1              OneTime[1].cdat[2] = 0;
1831   1              OneTime[1].cdat[3] = 0;
1832   1              OneTime[1].cdat[4] = 0x80;
1833   1              OneTime[1].cdat[5] = 0;
1834   1              OneTime[1].cdat[6] = 0;
1835   1              OneTime[1].cdat[7] = 0;
1836   1      //U8 SimpleButtonConfig(U8 button,U8 port,U32 ID,U8 mask[8],U8 value[8],count);
1837   1              SimpleButtonConfig(,0,0x4A3,OneTime[0].cdat,OneTime[1].cdat,1);
1838   1      */
1839   1      
1840   1      
1841   1      
1842   1      /*************************************************************************
1843   1              RxMessage filters / traps
1844   1              Below example:
1845   1              First half, Watches for ID 0x6E8 on can port 1 (C).  Only byte 3 matters 
1846   1              as the mask is set to 0's for all else.  The matching value required in  
1847   1              byte 3 is 0x58. 8 bytes expected.
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 31  

1848   1              Second half, configures output message 0x6E3 on port 1 (C). 8 bytes in 
1849   1              count.  mask is ANDed with cyclic message and ORed with value, but in 
1850   1              this example there is no cyclic message, therefor mask is ignored and 
1851   1              value is just output as the data 1 time. Take care to use the index value
1852   1              returned from the first function as input parameter to 2nd function
1853   1      **************************************************************************/
1854   1              OneTime[0].cdat[0] = 0;         // mask bits (0's don't cares, 1's are matches)
1855   1              OneTime[0].cdat[1] = 0;
1856   1              OneTime[0].cdat[2] = 0;         // using OneTime structure as temp storage
1857   1              OneTime[0].cdat[3] = 0xFF;      // this byte matters
1858   1              OneTime[0].cdat[4] = 0;
1859   1              OneTime[0].cdat[5] = 0;  
1860   1              OneTime[0].cdat[6] = 0;
1861   1              OneTime[0].cdat[7] = 0;
1862   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1863   1              OneTime[1].cdat[1] = 0;
1864   1              OneTime[1].cdat[2] = 0;
1865   1              OneTime[1].cdat[3] = 0x58;      // selector switches to x58 causes triggers
1866   1              OneTime[1].cdat[4] = 0;
1867   1              OneTime[1].cdat[5] = 0;
1868   1              OneTime[1].cdat[6] = 0;
1869   1              OneTime[1].cdat[7] = 0;
1870   1      // configure Rx filter, look for this message match
1871   1      //U8 RxMessageConfig1(U8 port,U32 ID,U8 mask[8],U8 value[8],U8 count);
1872   1              index = RxMessageConfig1(1,0x6E8,OneTime[0].cdat,OneTime[1].cdat,8);
1873   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1874   1              OneTime[0].cdat[1] = 0xFF;
1875   1              OneTime[0].cdat[2] = 0xFF;      // using OneTime structure as temp storage
1876   1              OneTime[0].cdat[3] = 0xFF;
1877   1              OneTime[0].cdat[4] = 0xFF;
1878   1              OneTime[0].cdat[5] = 0xFF;
1879   1              OneTime[0].cdat[6] = 0xFF;
1880   1              OneTime[0].cdat[7] = 0xFF;
1881   1              OneTime[1].cdat[0] = 0x88;      // values (ORed)
1882   1              OneTime[1].cdat[1] = 0x99;
1883   1              OneTime[1].cdat[2] = 0xAA;
1884   1              OneTime[1].cdat[3] = 0xBB;
1885   1              OneTime[1].cdat[4] = 0xCC;
1886   1              OneTime[1].cdat[5] = 0xDD;
1887   1              OneTime[1].cdat[6] = 0xEE;
1888   1              OneTime[1].cdat[7] = 0xFF;
1889   1      // configure Tx output caused by above Recieved message
1890   1      //void RxMessageConfig2(U8 index,U8 outport,U32 outID,U8 outmask[8],U8 outvalue[8],U8 cnt,U8 altercnt);
1891   1              RxMessageConfig2(index,1,0x6E3,OneTime[0].cdat,OneTime[1].cdat,8,1);
1892   1      
1893   1      
1894   1      // Detect and set for English
1895   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
1896   1              OneTime[0].cdat[1] = 0xFF;
1897   1              OneTime[0].cdat[2] = 0xFF;      
1898   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
1899   1              OneTime[1].cdat[1] = 3;
1900   1              OneTime[1].cdat[2] = 1;         // this byte must match
1901   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
1902   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1903   1              OneTime[0].cdat[1] = 0xFF;
1904   1              OneTime[0].cdat[2] = 0xFF;      
1905   1              OneTime[0].cdat[3] = 0xFF;
1906   1              OneTime[0].cdat[4] = 0xFF;
1907   1              OneTime[0].cdat[5] = 0xFF;
1908   1              OneTime[0].cdat[6] = 0x0;       // clear
1909   1              OneTime[0].cdat[7] = 0xFF;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 32  

1910   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1911   1              OneTime[1].cdat[1] = 0;
1912   1              OneTime[1].cdat[2] = 0;
1913   1              OneTime[1].cdat[3] = 0;
1914   1              OneTime[1].cdat[4] = 0;
1915   1              OneTime[1].cdat[5] = 0;
1916   1              OneTime[1].cdat[6] = 8;         // write
1917   1              OneTime[1].cdat[7] = 0;         // note altercount = 0 means permanant
1918   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
1919   1      
1920   1      // Detect and set for spa
1921   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
1922   1              OneTime[0].cdat[1] = 0xFF;
1923   1              OneTime[0].cdat[2] = 0xFF;      
1924   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
1925   1              OneTime[1].cdat[1] = 3;
1926   1              OneTime[1].cdat[2] = 4;         // this byte must match
1927   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
1928   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1929   1              OneTime[0].cdat[1] = 0xFF;
1930   1              OneTime[0].cdat[2] = 0xFF;      
1931   1              OneTime[0].cdat[3] = 0xFF;
1932   1              OneTime[0].cdat[4] = 0xFF;
1933   1              OneTime[0].cdat[5] = 0xFF;
1934   1              OneTime[0].cdat[6] = 0x0;       // clear
1935   1              OneTime[0].cdat[7] = 0xFF;
1936   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1937   1              OneTime[1].cdat[1] = 0;
1938   1              OneTime[1].cdat[2] = 0;
1939   1              OneTime[1].cdat[3] = 0;
1940   1              OneTime[1].cdat[4] = 0;
1941   1              OneTime[1].cdat[5] = 0;
1942   1              OneTime[1].cdat[6] = 0x20;      // write
1943   1              OneTime[1].cdat[7] = 0;
1944   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
1945   1      
1946   1      // Detect and set for ger
1947   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
1948   1              OneTime[0].cdat[1] = 0xFF;
1949   1              OneTime[0].cdat[2] = 0xFF;      
1950   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
1951   1              OneTime[1].cdat[1] = 3;
1952   1              OneTime[1].cdat[2] = 0;         // this byte must match
1953   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
1954   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1955   1              OneTime[0].cdat[1] = 0xFF;
1956   1              OneTime[0].cdat[2] = 0xFF;      
1957   1              OneTime[0].cdat[3] = 0xFF;
1958   1              OneTime[0].cdat[4] = 0xFF;
1959   1              OneTime[0].cdat[5] = 0xFF;
1960   1              OneTime[0].cdat[6] = 0x0;       // clear
1961   1              OneTime[0].cdat[7] = 0xFF;
1962   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1963   1              OneTime[1].cdat[1] = 0;
1964   1              OneTime[1].cdat[2] = 0;
1965   1              OneTime[1].cdat[3] = 0;
1966   1              OneTime[1].cdat[4] = 0;
1967   1              OneTime[1].cdat[5] = 0;
1968   1              OneTime[1].cdat[6] = 0;         // write
1969   1              OneTime[1].cdat[7] = 0;
1970   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
1971   1      
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 33  

1972   1      // Detect and set for fre
1973   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
1974   1              OneTime[0].cdat[1] = 0xFF;
1975   1              OneTime[0].cdat[2] = 0xFF;      
1976   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
1977   1              OneTime[1].cdat[1] = 3;
1978   1              OneTime[1].cdat[2] = 2;         // this byte must match
1979   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
1980   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
1981   1              OneTime[0].cdat[1] = 0xFF;
1982   1              OneTime[0].cdat[2] = 0xFF;      
1983   1              OneTime[0].cdat[3] = 0xFF;
1984   1              OneTime[0].cdat[4] = 0xFF;
1985   1              OneTime[0].cdat[5] = 0xFF;
1986   1              OneTime[0].cdat[6] = 0x0;       // clear
1987   1              OneTime[0].cdat[7] = 0xFF;
1988   1              OneTime[1].cdat[0] = 0;         // values (ORed)
1989   1              OneTime[1].cdat[1] = 0;
1990   1              OneTime[1].cdat[2] = 0;
1991   1              OneTime[1].cdat[3] = 0;
1992   1              OneTime[1].cdat[4] = 0;
1993   1              OneTime[1].cdat[5] = 0;
1994   1              OneTime[1].cdat[6] = 0x10;      // write
1995   1              OneTime[1].cdat[7] = 0;
1996   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
1997   1      
1998   1      // Detect and set for ita
1999   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2000   1              OneTime[0].cdat[1] = 0xFF;
2001   1              OneTime[0].cdat[2] = 0xFF;      
2002   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2003   1              OneTime[1].cdat[1] = 3;
2004   1              OneTime[1].cdat[2] = 3;         // this byte must match
2005   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2006   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2007   1              OneTime[0].cdat[1] = 0xFF;
2008   1              OneTime[0].cdat[2] = 0xFF;      
2009   1              OneTime[0].cdat[3] = 0xFF;
2010   1              OneTime[0].cdat[4] = 0xFF;
2011   1              OneTime[0].cdat[5] = 0xFF;
2012   1              OneTime[0].cdat[6] = 0x0;       // clear
2013   1              OneTime[0].cdat[7] = 0xFF;
2014   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2015   1              OneTime[1].cdat[1] = 0;
2016   1              OneTime[1].cdat[2] = 0;
2017   1              OneTime[1].cdat[3] = 0;
2018   1              OneTime[1].cdat[4] = 0;
2019   1              OneTime[1].cdat[5] = 0;
2020   1              OneTime[1].cdat[6] = 0x60;      // write
2021   1              OneTime[1].cdat[7] = 0;
2022   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2023   1      
2024   1      // Detect and set for jap
2025   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2026   1              OneTime[0].cdat[1] = 0xFF;
2027   1              OneTime[0].cdat[2] = 0xFF;      
2028   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2029   1              OneTime[1].cdat[1] = 3;
2030   1              OneTime[1].cdat[2] = 5;         // this byte must match
2031   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2032   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2033   1              OneTime[0].cdat[1] = 0xFF;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 34  

2034   1              OneTime[0].cdat[2] = 0xFF;      
2035   1              OneTime[0].cdat[3] = 0xFF;
2036   1              OneTime[0].cdat[4] = 0xFF;
2037   1              OneTime[0].cdat[5] = 0xFF;
2038   1              OneTime[0].cdat[6] = 0x0;       // clear
2039   1              OneTime[0].cdat[7] = 0xFF;
2040   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2041   1              OneTime[1].cdat[1] = 0;
2042   1              OneTime[1].cdat[2] = 0;
2043   1              OneTime[1].cdat[3] = 0;
2044   1              OneTime[1].cdat[4] = 0;
2045   1              OneTime[1].cdat[5] = 0;
2046   1              OneTime[1].cdat[6] = 0x50;      // write
2047   1              OneTime[1].cdat[7] = 0;
2048   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2049   1      
2050   1      // Detect and set for chs
2051   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2052   1              OneTime[0].cdat[1] = 0xFF;
2053   1              OneTime[0].cdat[2] = 0xFF;      
2054   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2055   1              OneTime[1].cdat[1] = 3;
2056   1              OneTime[1].cdat[2] = 9;         // this byte must match
2057   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2058   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2059   1              OneTime[0].cdat[1] = 0xFF;
2060   1              OneTime[0].cdat[2] = 0xFF;      
2061   1              OneTime[0].cdat[3] = 0xFF;
2062   1              OneTime[0].cdat[4] = 0xFF;
2063   1              OneTime[0].cdat[5] = 0xFF;
2064   1              OneTime[0].cdat[6] = 0x0;       // clear
2065   1              OneTime[0].cdat[7] = 0xFF;
2066   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2067   1              OneTime[1].cdat[1] = 0;
2068   1              OneTime[1].cdat[2] = 0;
2069   1              OneTime[1].cdat[3] = 0;
2070   1              OneTime[1].cdat[4] = 0;
2071   1              OneTime[1].cdat[5] = 0;
2072   1              OneTime[1].cdat[6] = 0x48;      // write
2073   1              OneTime[1].cdat[7] = 0;
2074   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2075   1      
2076   1      // Detect and set for cht
2077   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (0's don't cares, 1's are matches)
2078   1              OneTime[0].cdat[1] = 0xFF;
2079   1              OneTime[0].cdat[2] = 0xFF;      
2080   1              OneTime[1].cdat[0] = 0xA;       // values (ORed)
2081   1              OneTime[1].cdat[1] = 3;
2082   1              OneTime[1].cdat[2] = 0xE;       // this byte must match
2083   1              index = RxMessageConfig1(0,0x8A,OneTime[0].cdat,OneTime[1].cdat,3);
2084   1              OneTime[0].cdat[0] = 0xFF;      // mask bits (ANDed)
2085   1              OneTime[0].cdat[1] = 0xFF;
2086   1              OneTime[0].cdat[2] = 0xFF;      
2087   1              OneTime[0].cdat[3] = 0xFF;
2088   1              OneTime[0].cdat[4] = 0xFF;
2089   1              OneTime[0].cdat[5] = 0xFF;
2090   1              OneTime[0].cdat[6] = 0x0;       // clear
2091   1              OneTime[0].cdat[7] = 0xFF;
2092   1              OneTime[1].cdat[0] = 0;         // values (ORed)
2093   1              OneTime[1].cdat[1] = 0;
2094   1              OneTime[1].cdat[2] = 0;
2095   1              OneTime[1].cdat[3] = 0;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 35  

2096   1              OneTime[1].cdat[4] = 0;
2097   1              OneTime[1].cdat[5] = 0;
2098   1              OneTime[1].cdat[6] = 0x90;      // write
2099   1              OneTime[1].cdat[7] = 0;
2100   1              RxMessageConfig2(index,0,0x49D,OneTime[0].cdat,OneTime[1].cdat,8,0);
2101   1      
2102   1              // Configure Relay's
2103   1              RelayCnf[3] = REL_IGN | 1 | REL_NOT;    // relay 4 comes on with Ignition switch setting not 1
2104   1              //RelayCnf[2] = REL_BUTT | 1 | REL_TOG; // relay 3 toggles with button 1
2105   1              //RelayCnf[1] = REL_RX | 0 | REL_PULSE; // relay 2 with first (0) rxtrap configured
2106   1              //RelayCnf[0] = REL_TX | 3 | REL_PULSE; // relay 1 with 4th (3) TxMesg configured
2107   1      
2108   1      /*************************************************************************
2109   1              User running loop 
2110   1      **************************************************************************/
2111   1              cnt = 0;
2112   1              counter =0;
2113   1              
2114   1              while(!(keyChange & 0xF))
2115   1              {
2116   2                      
2117   2                      if (RxCAN0)             // new message to process
2118   2                      {
2119   3                              for (index = 1 ; index < RX0BUFFERS && rxframe0[index].MsgNum>=RX0BUFFERS ; index++);
2120   3      
2121   3                              if (index < RX0BUFFERS)
2122   3                              {
2123   4                                      ProcessRx(0,index);
2124   4                                      rxframe0[index].MsgNum = 0;
2125   4                              }
2126   3                              RxCAN0 = 0;
2127   3                      }
2128   2                      if (RxCAN1)             // new message to process
2129   2                      {
2130   3                              error = CAN1readStatus();
2131   3      
2132   3                              index = RX1BUFFERS;
2133   3                              index1 = RX1BUFFERS;
2134   3                              if (error & MCP_RX1IF)
2135   3                                      index1 = CAN1read_canMsg( MCP_READ_RX1 );        
2136   3                              if (error & MCP_RX0IF)
2137   3                                      index = CAN1read_canMsg( MCP_READ_RX0 );        
2138   3                              if (error = CAN1readRegister(MCP_EFLG))
2139   3                              {
2140   4                                      ErrCnt++;
2141   4                                      AlterMessageByte(1,0x6E2,7,1,ErrCnt,0);
2142   4      
2143   4                                      if (error & MCP_EFLG_RX1OVR)
2144   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX1OVR,0);
2145   4                                      if (error & MCP_EFLG_RX0OVR)
2146   4                                              CAN1modifyRegister(MCP_EFLG,MCP_EFLG_RX0OVR,0);
2147   4                              }
2148   3      
2149   3                              // clear int flags
2150   3                              IE0 = 0;                                        // clear IE0 flag re-enabling interupt
2151   3                              RxCAN1 = 0;                                     // clear my flag interupt occured
2152   3                              EX0 = 1;                                        // enable CAN1 interupt
2153   3      
2154   3                              if (index < RX1BUFFERS)                         // process recieved message from Rx0
2155   3                              {
2156   4                                      ProcessRx(1,index);             // CAN1 messages
2157   4                              }
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 36  

2158   3                              if (index1 < RX1BUFFERS)                        // process recieved message from Rx1
2159   3                              {
2160   4                                      ProcessRx(1,index1);
2161   4                              }
2162   3                      }
2163   2      
2164   2                      if (StartTicks + ONESEC < msticks )     // every second
2165   2                      {
2166   3                              StartTicks = msticks;
2167   3                              LED1 ^= 1;
2168   3      
2169   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
2170   3                              if (index1 < TXBUFFS)                           // empty one time available
2171   3                              {
2172   4                                      OneTime[index1].cdat[0] = (U8)(keys>>24);
2173   4                                      OneTime[index1].cdat[1] = (U8)(keys>>16);
2174   4                                      OneTime[index1].cdat[2] = (U8)(keys>>8);
2175   4                                      OneTime[index1].cdat[3] = (U8)keys;
2176   4                                      OneTime[index1].cdat[4] = CAN1readStatus();
2177   4                                      OneTime[index1].cdat[5] = CAN1readRxStat();
2178   4                                      OneTime[index1].cdat[6] = CAN1readRegister(MCP_CANSTAT);
2179   4                                      OneTime[index1].cdat[7] = CAN1readRegister(MCP_CANINTF);
2180   4                                      AlterMessageByte(0,0x6EA,0,OneTime[index1].cdat,8,1);
2181   4                              }
2182   3      
2183   3                              // VIN
2184   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
2185   3                              if (index1 < TXBUFFS)                           // empty one time available
2186   3                              {
2187   4                                      switch (vin++)
2188   4                                      {
2189   5                                              case 0:
2190   5                                                      OneTime[index1].cdat[0] = 0;
2191   5                                                      for (index = 0 ; index < 7 ; index++)
2192   5                                                              OneTime[index1].cdat[1+index] = VIN[index];
2193   5                                                      break;
2194   5                                              case 1:
2195   5                                                      OneTime[index1].cdat[0] = 1;
2196   5                                                      for (index = 7 ; index < 14 ; index++)
2197   5                                                              OneTime[index1].cdat[index-6] = VIN[index];
2198   5                                                      break;
2199   5                                              case 2:
2200   5                                                      OneTime[index1].cdat[0] = 2;
2201   5                                                      for (index = 14 ; index < 17 ; index++)
2202   5                                                              OneTime[index1].cdat[index-13] = VIN[index];
2203   5                                                      vin = 0;
2204   5                                                      break;
2205   5                                      }
2206   4                                      AlterMessageByte(0,0x3E0,0,OneTime[index1].cdat,8,0);
2207   4                              }
2208   3      
2209   3                              if (counter++ >= 9)     // test every 10 seconds alter 6E2 message
2210   3                              {
2211   4                                      for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
2212   4                                      if (index1 < TXBUFFS)                           // empty one time available
2213   4                                      {
2214   5                                              OneTime[index1].cdat[0] = cnt++;
2215   5                                              AlterMessageByte(1,0x6E2,6,OneTime[index1].cdat,1,2);
2216   5                                              counter = 0;
2217   5                                      }
2218   4                              }
2219   3                      }
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 37  

2220   2      
2221   2      
2222   2                      if (RelayChange)
2223   2                              CheckRelay();
2224   2      
2225   2                      // check for buttons pressed and process
2226   2                      if (keyChange & 0xFFFFF00)      // At least one Buttons changed state
2227   2                      {
2228   3                              CheckButts();                   // SimpleButton Check
2229   3      
2230   3                              keyChange &= (U32)((BUTTONMASK<<8) & 0xFF);     // clear unused buttons
2231   3                      }
2232   2      
2233   2      
2234   2                      if (keyChange & 0xF0)           // Ignition change
2235   2                      {
2236   3                              // check if a relay is set to Ignition change
2237   3                              for (index1 = 0 ; index1 < 4; index1++){
2238   4                                      if ((RelayCnf[index1] & 0xF00) == REL_IGN)      // Relay controled by IGN select
2239   4                                      {
2240   5                                              if ((RelayCnf[index1]&0xFF) == ((keys>>4)&0xF)) // matching Select
2241   5                                                      RelayChange |= 1<<index1;                       // flag for relay "on" change
2242   5                                              else
2243   5                                                      RelayChange |= 0x10<<index1;            // flag for relay "off" change
2244   5                                      }
2245   4                              }
2246   3      
2247   3                              for (index1 = 0 ; index1 < TXBUFFS && OneTime[index1].arbID ; index1++);
2248   3                              if (index1 < TXBUFFS)                           // empty one time available
2249   3                              {
2250   4                                      IGN_OFF = 0;                    // default IGN_OFF flag to off
2251   4                                      switch(keys & 0xF0)
2252   4                                      {
2253   5                                              case 0x10:      // IGN_OFF
2254   5                                                      // ID 190, alter byte 0,1 
2255   5                                                      OneTime[index1].cdat[0] = 0x00;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2256   5                                                      OneTime[index1].cdat[1] = 0x01;                 //key in ignition
2257   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2258   5      
2259   5                                                      // ID 98, alter bytes 2,3  
2260   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2261   5                                                      OneTime[index1].cdat[1] = 0x0;
2262   5                                                      OneTime[index1].cdat[2] = 0x0;
2263   5                                                      OneTime[index1].cdat[3] = 0x0;
2264   5                                                      OneTime[index1].cdat[4] = 0x0;                  // 0 speed                      
2265   5                                                      OneTime[index1].cdat[5] = 0x0;
2266   5                                                      OneTime[index1].cdat[6] = 0x0;
2267   5                                                      OneTime[index1].cdat[7] = 0x0;
2268   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2269   5                                                      IGN_OFF = 1;    // TURN on IGN_OFF flag
2270   5                                                      break;
2271   5                                              case 0x20:      // IGN_ACC
2272   5                                                      // ID 190, alter byte 0,1 
2273   5                                                      OneTime[index1].cdat[0] = 0x03;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2274   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2275   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2276   5      
2277   5                                                      // ID 98, alter bytes 2,3  
2278   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2279   5                                                      OneTime[index1].cdat[1] = 0x0;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 38  

2280   5                                                      OneTime[index1].cdat[2] = 0x0;
2281   5                                                      OneTime[index1].cdat[3] = 0x0;
2282   5                                                      OneTime[index1].cdat[4] = 0x34;                         // 0 speed                      
2283   5                                                      OneTime[index1].cdat[5] = 0x0;
2284   5                                                      OneTime[index1].cdat[6] = 0x07;
2285   5                                                      OneTime[index1].cdat[7] = 0xD0;
2286   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2287   5                                                      break;
2288   5                                              case 0x30:      // IGN_RUN_0
2289   5                                                      // ID 190, alter byte 0,1 
2290   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2291   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2292   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2293   5      
2294   5                                                      // ID 98, alter bytes 2,3  
2295   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2296   5                                                      OneTime[index1].cdat[1] = 0x0;
2297   5                                                      OneTime[index1].cdat[2] = 0x0;
2298   5                                                      OneTime[index1].cdat[3] = 0x0;
2299   5                                                      OneTime[index1].cdat[4] = 0x34;                         // 0 speed                      
2300   5                                                      OneTime[index1].cdat[5] = 0x0;
2301   5                                                      OneTime[index1].cdat[6] = 0x07;
2302   5                                                      OneTime[index1].cdat[7] = 0xD0;
2303   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2304   5                                                      break;
2305   5                                              case 0x40:      // IGN_RUN_5
2306   5                                              // ID 190, alter byte 0,1 
2307   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2308   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2309   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2310   5      
2311   5                                                      // ID 98, alter bytes 2,3  
2312   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2313   5                                                      OneTime[index1].cdat[1] = 0x0;
2314   5                                                      OneTime[index1].cdat[2] = 0x04;
2315   5                                                      OneTime[index1].cdat[3] = 0x06;
2316   5                                                      OneTime[index1].cdat[4] = 0x34;                         // 0 speed                      
2317   5                                                      OneTime[index1].cdat[5] = 0x0;
2318   5                                                      OneTime[index1].cdat[6] = 0x07;
2319   5                                                      OneTime[index1].cdat[7] = 0xD0;
2320   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2321   5                                                      break;
2322   5                                              case 0x50:      // IGN_RUN_10
2323   5                                              // ID 190, alter byte 0,1 
2324   5                                                      OneTime[index1].cdat[0] = 0x04;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2325   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2326   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2327   5      
2328   5                                                      // ID 98, alter bytes 2,3  
2329   5                                                      OneTime[index1].cdat[0] = 0x0;                                          
2330   5                                                      OneTime[index1].cdat[1] = 0x0;
2331   5                                                      OneTime[index1].cdat[2] = 0x08;
2332   5                                                      OneTime[index1].cdat[3] = 0x0C;
2333   5                                                      OneTime[index1].cdat[4] = 0x34;                                         
2334   5                                                      OneTime[index1].cdat[5] = 0x0;
2335   5                                                      OneTime[index1].cdat[6] = 0x07;
2336   5                                                      OneTime[index1].cdat[7] = 0xD0;
2337   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,8,0);
2338   5                                                      break;
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 39  

2339   5                                              case 0x60:      // IGN_START
2340   5                                                      // ID 190, alter byte 0,1 
2341   5                                                      OneTime[index1].cdat[0] = 0x05;         //ignition run, start not active  04 = run ;02=ACC ;0D= Norma
             -lStart, key in Ign,                                           
2342   5                                                      OneTime[index1].cdat[1] = 0x02;                 //key in ignition
2343   5                                                      AlterMessageByte(0,0x122,0,OneTime[index1].cdat,2,0);
2344   5      
2345   5                                                      // ID 98, alter bytes 2,3  
2346   5                                                      OneTime[index1].cdat[0] = 0x0;                  // 0 speed                      
2347   5                                                      OneTime[index1].cdat[1] = 0x0;
2348   5                                                      OneTime[index1].cdat[2] = 0x0;
2349   5                                                      OneTime[index1].cdat[3] = 0x0;
2350   5                                                      AlterMessageByte(0,0x322,2,OneTime[index1].cdat,4,0);
2351   5                                                      break;
2352   5                                              case 0x70:
2353   5                                                      break;
2354   5                                              case 0x80:
2355   5                                                      break;
2356   5                                      }
2357   4      
2358   4                              keyChange &= ~0xF0;             // clear Ignition nibble
2359   4                              }
2360   3                      }
2361   2                      
2362   2              }
2363   1      }
2364          void User3()    // program select 3
2365          {       
2366   1              U8 cnt=0;
2367   1      
2368   1              while(!(keyChange & 0xF))
2369   1              {
2370   2                      for (cnt = 0 ; cnt < 6 ; cnt++)
2371   2                      {
2372   3                              LED1 ^= 1;
2373   3                              mSecDelay(100);
2374   3                      }
2375   2              mSecDelay(1400);
2376   2              }
2377   1      }
2378          void User4()    // program select 4
2379          {       
2380   1              U8 cnt=0;
2381   1      
2382   1              while(!(keyChange & 0xF))
2383   1              {
2384   2                      for (cnt = 0 ; cnt < 8 ; cnt++)
2385   2                      {
2386   3                              LED1 ^= 1;
2387   3                              mSecDelay(100);
2388   3                      }
2389   2              mSecDelay(1200);
2390   2              }
2391   1      }
2392          void User5()    // program select 5
2393          {       
2394   1              U8 cnt=0;
2395   1      
2396   1              while(!(keyChange & 0xF))
2397   1              {
2398   2                      for (cnt = 0 ; cnt < 10 ; cnt++)
2399   2                      {
C51 COMPILER V9.51   USER                                                                  06/01/2016 09:49:50 PAGE 40  

2400   3                              LED1 ^= 1;
2401   3                              mSecDelay(100);
2402   3                      }
2403   2              mSecDelay(1000);
2404   2              }
2405   1      }
2406          void User6()    // program select 6
2407          {       
2408   1              U8 cnt=0;
2409   1      
2410   1              while(!(keyChange & 0xF))
2411   1              {
2412   2                      for (cnt = 0 ; cnt < 12 ; cnt++)
2413   2                      {
2414   3                              LED1 ^= 1;
2415   3                              mSecDelay(100);
2416   3                      }
2417   2              mSecDelay(800);
2418   2              }
2419   1      }
2420          void User7()    // program select 7
2421          {       
2422   1              U8 cnt=0;
2423   1      
2424   1              while(!(keyChange & 0xF))
2425   1              {
2426   2                      for (cnt = 0 ; cnt < 14 ; cnt++)
2427   2                      {
2428   3                              LED1 ^= 1;
2429   3                              mSecDelay(100);
2430   3                      }
2431   2              mSecDelay(600);
2432   2              }
2433   1      }
2434          
2435          void User8(void)        // example program select 8
2436          {
2437   1      }
2438          
2439          
2440          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12371    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      61
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
